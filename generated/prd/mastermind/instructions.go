// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package mastermind

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

const ProgramName = "Mastermind"

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("2pbhpVLBKvqKXNbV6V2cvYME1dE9KCb39jZczsZnoTfu")

func SetProgramID(PublicKey ag_solanago.PublicKey) {
	ProgramID = PublicKey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	AssociatedTokenProgram = ag_solanago.MustPublicKeyFromBase58("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")

	CreatePoolFee = ag_solanago.MustPublicKeyFromBase58("DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8")

	EventAuthorityPDA = ag_solanago.MustPublicKeyFromBase58("7pPLQ8vCwrLKF464PwX6fttxFe5QgKVWp1nSVyxExHei")

	FeeNftOwnerPDA = ag_solanago.MustPublicKeyFromBase58("US79y37QQ79qg1qNJjbYU28egQ6zrkczzP5XRRFcNmw")

	LockingProgram = ag_solanago.MustPublicKeyFromBase58("LockrWmn6K5twhz3y9w1dQERbmgSaRkfnTeTKbpofwE")

	MemoProgram = ag_solanago.MustPublicKeyFromBase58("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr")

	RaydiumCPMMProgram = ag_solanago.MustPublicKeyFromBase58("CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C")

	RentProgram = ag_solanago.MustPublicKeyFromBase58("SysvarRent111111111111111111111111111111111")

	StatePDA = ag_solanago.MustPublicKeyFromBase58("3UxuJKsLEs33UdAid3jAGVbYCk7bJ6SUG1gruZNDBQC8")

	SystemProgram = ag_solanago.MustPublicKeyFromBase58("11111111111111111111111111111111")

	Token22Program = ag_solanago.MustPublicKeyFromBase58("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

	TokenMetadataProgram = ag_solanago.MustPublicKeyFromBase58("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")

	TokenProgram = ag_solanago.MustPublicKeyFromBase58("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
)

var (
	Instruction_BecomeAuthority = ag_binary.TypeID([8]byte{25, 249, 222, 93, 121, 106, 104, 46})

	Instruction_BuyExactIn = ag_binary.TypeID([8]byte{250, 234, 13, 123, 213, 156, 19, 236})

	Instruction_BuyExactOut = ag_binary.TypeID([8]byte{24, 211, 116, 40, 105, 3, 153, 56})

	Instruction_BuyMaxOut = ag_binary.TypeID([8]byte{96, 177, 203, 117, 183, 65, 196, 177})

	Instruction_CollectCpFees = ag_binary.TypeID([8]byte{8, 30, 51, 199, 209, 184, 247, 133})

	Instruction_Create = ag_binary.TypeID([8]byte{24, 30, 200, 40, 5, 28, 7, 119})

	Instruction_Initialize = ag_binary.TypeID([8]byte{175, 175, 109, 31, 13, 152, 155, 237})

	Instruction_MigrateToRadium = ag_binary.TypeID([8]byte{96, 230, 91, 140, 139, 40, 235, 142})

	Instruction_SellExactIn = ag_binary.TypeID([8]byte{149, 39, 222, 155, 211, 124, 152, 26})

	Instruction_SellExactOut = ag_binary.TypeID([8]byte{95, 200, 71, 34, 8, 9, 11, 166})

	Instruction_SetCurveParams = ag_binary.TypeID([8]byte{133, 183, 61, 96, 198, 233, 62, 13})

	Instruction_SetFeeBps = ag_binary.TypeID([8]byte{2, 161, 245, 141, 111, 32, 39, 198})

	Instruction_SetFeeReceiver = ag_binary.TypeID([8]byte{222, 168, 176, 101, 242, 87, 191, 16})

	Instruction_SetMigrationLotSize = ag_binary.TypeID([8]byte{224, 245, 51, 3, 173, 186, 250, 230})

	Instruction_SetMigrationRefund = ag_binary.TypeID([8]byte{148, 239, 194, 248, 85, 104, 213, 52})

	Instruction_SetMigrator = ag_binary.TypeID([8]byte{209, 164, 101, 138, 178, 62, 195, 249})

	Instruction_SetPendingAuthority = ag_binary.TypeID([8]byte{175, 71, 167, 223, 49, 144, 102, 193})

	Instruction_SetWrapperMint = ag_binary.TypeID([8]byte{65, 169, 74, 24, 18, 148, 174, 154})

	Instruction_SyncWrapper = ag_binary.TypeID([8]byte{58, 56, 206, 153, 224, 221, 169, 86})

	Instruction_WrapSolForCurve = ag_binary.TypeID([8]byte{32, 147, 121, 169, 176, 40, 51, 95})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_BecomeAuthority:
		return "BecomeAuthority"
	case Instruction_BuyExactIn:
		return "BuyExactIn"
	case Instruction_BuyExactOut:
		return "BuyExactOut"
	case Instruction_BuyMaxOut:
		return "BuyMaxOut"
	case Instruction_CollectCpFees:
		return "CollectCpFees"
	case Instruction_Create:
		return "Create"
	case Instruction_Initialize:
		return "Initialize"
	case Instruction_MigrateToRadium:
		return "MigrateToRadium"
	case Instruction_SellExactIn:
		return "SellExactIn"
	case Instruction_SellExactOut:
		return "SellExactOut"
	case Instruction_SetCurveParams:
		return "SetCurveParams"
	case Instruction_SetFeeBps:
		return "SetFeeBps"
	case Instruction_SetFeeReceiver:
		return "SetFeeReceiver"
	case Instruction_SetMigrationLotSize:
		return "SetMigrationLotSize"
	case Instruction_SetMigrationRefund:
		return "SetMigrationRefund"
	case Instruction_SetMigrator:
		return "SetMigrator"
	case Instruction_SetPendingAuthority:
		return "SetPendingAuthority"
	case Instruction_SetWrapperMint:
		return "SetWrapperMint"
	case Instruction_SyncWrapper:
		return "SyncWrapper"
	case Instruction_WrapSolForCurve:
		return "WrapSolForCurve"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			Name: "become_authority", Type: (*BecomeAuthority)(nil),
		},
		{
			Name: "buy_exact_in", Type: (*BuyExactIn)(nil),
		},
		{
			Name: "buy_exact_out", Type: (*BuyExactOut)(nil),
		},
		{
			Name: "buy_max_out", Type: (*BuyMaxOut)(nil),
		},
		{
			Name: "collect_cp_fees", Type: (*CollectCpFees)(nil),
		},
		{
			Name: "create", Type: (*Create)(nil),
		},
		{
			Name: "initialize", Type: (*Initialize)(nil),
		},
		{
			Name: "migrate_to_radium", Type: (*MigrateToRadium)(nil),
		},
		{
			Name: "sell_exact_in", Type: (*SellExactIn)(nil),
		},
		{
			Name: "sell_exact_out", Type: (*SellExactOut)(nil),
		},
		{
			Name: "set_curve_params", Type: (*SetCurveParams)(nil),
		},
		{
			Name: "set_fee_bps", Type: (*SetFeeBps)(nil),
		},
		{
			Name: "set_fee_receiver", Type: (*SetFeeReceiver)(nil),
		},
		{
			Name: "set_migration_lot_size", Type: (*SetMigrationLotSize)(nil),
		},
		{
			Name: "set_migration_refund", Type: (*SetMigrationRefund)(nil),
		},
		{
			Name: "set_migrator", Type: (*SetMigrator)(nil),
		},
		{
			Name: "set_pending_authority", Type: (*SetPendingAuthority)(nil),
		},
		{
			Name: "set_wrapper_mint", Type: (*SetWrapperMint)(nil),
		},
		{
			Name: "sync_wrapper", Type: (*SyncWrapper)(nil),
		},
		{
			Name: "wrap_sol_for_curve", Type: (*WrapSolForCurve)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := decodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func decodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
