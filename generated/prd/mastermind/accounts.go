// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package mastermind

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type AmmConfigAccount struct {
	// Bump to identify PDA
	Bump uint8

	// Status to control if new pool can be create
	DisableCreatePool bool

	// Config index
	Index uint16

	// The trade fee, denominated in hundredths of a bip (10^-6)
	TradeFeeRate uint64

	// The protocol fee
	ProtocolFeeRate uint64

	// The fund fee, denominated in hundredths of a bip (10^-6)
	FundFeeRate uint64

	// Fee for create a new pool
	CreatePoolFee uint64

	// Address of the protocol fee owner
	ProtocolOwner ag_solanago.PublicKey

	// Address of the fund fee owner
	FundOwner ag_solanago.PublicKey

	// padding
	padding [16]uint64
}

var AmmConfigAccountDiscriminator = [8]byte{218, 244, 33, 104, 203, 203, 43, 111}

func (obj AmmConfigAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(AmmConfigAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `DisableCreatePool` param:
	err = encoder.Encode(obj.DisableCreatePool)
	if err != nil {
		return err
	}
	// Serialize `Index` param:
	err = encoder.Encode(obj.Index)
	if err != nil {
		return err
	}
	// Serialize `TradeFeeRate` param:
	err = encoder.Encode(obj.TradeFeeRate)
	if err != nil {
		return err
	}
	// Serialize `ProtocolFeeRate` param:
	err = encoder.Encode(obj.ProtocolFeeRate)
	if err != nil {
		return err
	}
	// Serialize `FundFeeRate` param:
	err = encoder.Encode(obj.FundFeeRate)
	if err != nil {
		return err
	}
	// Serialize `CreatePoolFee` param:
	err = encoder.Encode(obj.CreatePoolFee)
	if err != nil {
		return err
	}
	// Serialize `ProtocolOwner` param:
	err = encoder.Encode(obj.ProtocolOwner)
	if err != nil {
		return err
	}
	// Serialize `FundOwner` param:
	err = encoder.Encode(obj.FundOwner)
	if err != nil {
		return err
	}
	// Serialize `padding` param:
	err = encoder.Encode(obj.padding)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AmmConfigAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(AmmConfigAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[218 244 33 104 203 203 43 111]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `DisableCreatePool`:
	err = decoder.Decode(&obj.DisableCreatePool)
	if err != nil {
		return err
	}
	// Deserialize `Index`:
	err = decoder.Decode(&obj.Index)
	if err != nil {
		return err
	}
	// Deserialize `TradeFeeRate`:
	err = decoder.Decode(&obj.TradeFeeRate)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolFeeRate`:
	err = decoder.Decode(&obj.ProtocolFeeRate)
	if err != nil {
		return err
	}
	// Deserialize `FundFeeRate`:
	err = decoder.Decode(&obj.FundFeeRate)
	if err != nil {
		return err
	}
	// Deserialize `CreatePoolFee`:
	err = decoder.Decode(&obj.CreatePoolFee)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolOwner`:
	err = decoder.Decode(&obj.ProtocolOwner)
	if err != nil {
		return err
	}
	// Deserialize `FundOwner`:
	err = decoder.Decode(&obj.FundOwner)
	if err != nil {
		return err
	}
	// Deserialize `padding`:
	err = decoder.Decode(&obj.padding)
	if err != nil {
		return err
	}
	return nil
}

type CurveAccount struct {
	Bump    uint8
	Version uint8
	Data    CurveDataV1
}

var CurveAccountDiscriminator = [8]byte{191, 180, 249, 66, 180, 71, 51, 182}

func (obj CurveAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(CurveAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Version` param:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return err
	}
	// Serialize `Data` param:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CurveAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(CurveAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[191 180 249 66 180 71 51 182]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return err
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}

type LockedCpLiquidityStateAccount struct {
	// The Locked liquidity amount without claimed lp fee
	LockedLpAmount uint64

	// Claimed lp fee amount
	ClaimedLpAmount uint64

	// Unclaimed lp fee amount
	UnclaimedLpAmount uint64

	// Last updated cp pool lp total supply
	LastLp uint64

	// Last updated cp pool k
	LastK ag_binary.Uint128

	// Account update recent epoch
	RecentEpoch uint64

	// The ID of the pool with which this record is connected
	PoolId ag_solanago.PublicKey

	// nft mint to check who has authority to collect fee
	FeeNftMint ag_solanago.PublicKey

	// The owner who has locked liquidity
	LockedOwner ag_solanago.PublicKey

	// The mint of locked lp token
	LockedLpMint ag_solanago.PublicKey

	// Unused bytes for future upgrades.
	padding [8]uint64
}

var LockedCpLiquidityStateAccountDiscriminator = [8]byte{25, 10, 238, 197, 207, 234, 73, 22}

func (obj LockedCpLiquidityStateAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(LockedCpLiquidityStateAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `LockedLpAmount` param:
	err = encoder.Encode(obj.LockedLpAmount)
	if err != nil {
		return err
	}
	// Serialize `ClaimedLpAmount` param:
	err = encoder.Encode(obj.ClaimedLpAmount)
	if err != nil {
		return err
	}
	// Serialize `UnclaimedLpAmount` param:
	err = encoder.Encode(obj.UnclaimedLpAmount)
	if err != nil {
		return err
	}
	// Serialize `LastLp` param:
	err = encoder.Encode(obj.LastLp)
	if err != nil {
		return err
	}
	// Serialize `LastK` param:
	err = encoder.Encode(obj.LastK)
	if err != nil {
		return err
	}
	// Serialize `RecentEpoch` param:
	err = encoder.Encode(obj.RecentEpoch)
	if err != nil {
		return err
	}
	// Serialize `PoolId` param:
	err = encoder.Encode(obj.PoolId)
	if err != nil {
		return err
	}
	// Serialize `FeeNftMint` param:
	err = encoder.Encode(obj.FeeNftMint)
	if err != nil {
		return err
	}
	// Serialize `LockedOwner` param:
	err = encoder.Encode(obj.LockedOwner)
	if err != nil {
		return err
	}
	// Serialize `LockedLpMint` param:
	err = encoder.Encode(obj.LockedLpMint)
	if err != nil {
		return err
	}
	// Serialize `padding` param:
	err = encoder.Encode(obj.padding)
	if err != nil {
		return err
	}
	return nil
}

func (obj *LockedCpLiquidityStateAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(LockedCpLiquidityStateAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[25 10 238 197 207 234 73 22]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `LockedLpAmount`:
	err = decoder.Decode(&obj.LockedLpAmount)
	if err != nil {
		return err
	}
	// Deserialize `ClaimedLpAmount`:
	err = decoder.Decode(&obj.ClaimedLpAmount)
	if err != nil {
		return err
	}
	// Deserialize `UnclaimedLpAmount`:
	err = decoder.Decode(&obj.UnclaimedLpAmount)
	if err != nil {
		return err
	}
	// Deserialize `LastLp`:
	err = decoder.Decode(&obj.LastLp)
	if err != nil {
		return err
	}
	// Deserialize `LastK`:
	err = decoder.Decode(&obj.LastK)
	if err != nil {
		return err
	}
	// Deserialize `RecentEpoch`:
	err = decoder.Decode(&obj.RecentEpoch)
	if err != nil {
		return err
	}
	// Deserialize `PoolId`:
	err = decoder.Decode(&obj.PoolId)
	if err != nil {
		return err
	}
	// Deserialize `FeeNftMint`:
	err = decoder.Decode(&obj.FeeNftMint)
	if err != nil {
		return err
	}
	// Deserialize `LockedOwner`:
	err = decoder.Decode(&obj.LockedOwner)
	if err != nil {
		return err
	}
	// Deserialize `LockedLpMint`:
	err = decoder.Decode(&obj.LockedLpMint)
	if err != nil {
		return err
	}
	// Deserialize `padding`:
	err = decoder.Decode(&obj.padding)
	if err != nil {
		return err
	}
	return nil
}

type StateAccount struct {
	Bump    uint8
	Version uint8
	Data    StateDataV1
}

var StateAccountDiscriminator = [8]byte{216, 146, 107, 94, 104, 75, 182, 177}

func (obj StateAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(StateAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Bump` param:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return err
	}
	// Serialize `Version` param:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return err
	}
	// Serialize `Data` param:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StateAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(StateAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[216 146 107 94 104 75 182 177]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return err
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return err
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}
