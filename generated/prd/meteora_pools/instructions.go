// Program for AMM
// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package meteora_pools

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

const ProgramName = "MeteoraPools"

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB")

func SetProgramID(PublicKey ag_solanago.PublicKey) {
	ProgramID = PublicKey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var ()

var (
	// Initialize a new permissioned pool.
	Instruction_InitializePermissionedPool = ag_binary.TypeID([8]byte{77, 85, 178, 157, 50, 48, 212, 126})

	// Initialize a new permissionless pool.
	Instruction_InitializePermissionlessPool = ag_binary.TypeID([8]byte{118, 173, 41, 157, 173, 72, 97, 103})

	// Initialize a new permissionless pool with customized fee tier
	Instruction_InitializePermissionlessPoolWithFeeTier = ag_binary.TypeID([8]byte{6, 135, 68, 147, 229, 82, 169, 113})

	// Enable or disable a pool. A disabled pool allow only remove balanced liquidity operation.
	Instruction_EnableOrDisablePool = ag_binary.TypeID([8]byte{128, 6, 228, 131, 55, 161, 52, 169})

	// Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool.
	Instruction_Swap = ag_binary.TypeID([8]byte{248, 198, 158, 145, 225, 117, 135, 200})

	// Withdraw only single token from the pool. Only supported by pool with stable swap curve.
	Instruction_RemoveLiquiditySingleSide = ag_binary.TypeID([8]byte{84, 84, 177, 66, 254, 185, 10, 251})

	// Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve.
	Instruction_AddImbalanceLiquidity = ag_binary.TypeID([8]byte{79, 35, 122, 84, 173, 15, 93, 191})

	// Withdraw tokens from the pool in a balanced ratio. User will still able to withdraw from pool even the pool is disabled. This allow user to exit their liquidity when there's some unforeseen event happen.
	Instruction_RemoveBalanceLiquidity = ag_binary.TypeID([8]byte{133, 109, 44, 179, 56, 238, 114, 33})

	// Deposit tokens to the pool in a balanced ratio.
	Instruction_AddBalanceLiquidity = ag_binary.TypeID([8]byte{168, 227, 50, 62, 189, 171, 84, 176})

	// Update trading fee charged for liquidity provider, and admin.
	Instruction_SetPoolFees = ag_binary.TypeID([8]byte{102, 44, 158, 54, 205, 37, 126, 78})

	// Update swap curve parameters. This function do not allow update of curve type. For example: stable swap curve to constant product curve. Only supported by pool with stable swap curve.
	// Only amp is allowed to be override. The other attributes of stable swap curve will be ignored.
	Instruction_OverrideCurveParam = ag_binary.TypeID([8]byte{98, 86, 204, 51, 94, 71, 69, 187})

	// Get the general information of the pool.
	Instruction_GetPoolInfo = ag_binary.TypeID([8]byte{9, 48, 220, 101, 22, 240, 78, 200})

	// Bootstrap the pool when liquidity is depleted.
	Instruction_BootstrapLiquidity = ag_binary.TypeID([8]byte{4, 228, 215, 71, 225, 253, 119, 206})

	// Create mint metadata account for old pools
	Instruction_CreateMintMetadata = ag_binary.TypeID([8]byte{13, 70, 168, 41, 250, 100, 148, 90})

	// Create lock account
	Instruction_CreateLockEscrow = ag_binary.TypeID([8]byte{54, 87, 165, 19, 69, 227, 218, 224})

	// Lock Lp token
	Instruction_Lock = ag_binary.TypeID([8]byte{21, 19, 208, 43, 237, 62, 255, 87})

	// Claim fee
	Instruction_ClaimFee = ag_binary.TypeID([8]byte{169, 32, 79, 137, 136, 232, 70, 137})

	// Create config
	Instruction_CreateConfig = ag_binary.TypeID([8]byte{201, 207, 243, 114, 75, 111, 47, 189})

	// Close config
	Instruction_CloseConfig = ag_binary.TypeID([8]byte{145, 9, 72, 157, 95, 125, 61, 85})

	// Initialize permissionless pool with config
	Instruction_InitializePermissionlessConstantProductPoolWithConfig = ag_binary.TypeID([8]byte{7, 166, 138, 171, 206, 171, 236, 244})

	// Initialize permissionless pool with config 2
	Instruction_InitializePermissionlessConstantProductPoolWithConfig2 = ag_binary.TypeID([8]byte{48, 149, 220, 130, 61, 11, 9, 178})

	// Initialize permissionless pool with customizable params
	Instruction_InitializeCustomizablePermissionlessConstantProductPool = ag_binary.TypeID([8]byte{145, 24, 172, 194, 219, 125, 3, 190})

	// Update activation slot
	Instruction_UpdateActivationPoint = ag_binary.TypeID([8]byte{150, 62, 125, 219, 171, 220, 26, 237})

	// Withdraw protocol fee
	Instruction_WithdrawProtocolFees = ag_binary.TypeID([8]byte{11, 68, 165, 98, 18, 208, 134, 73})

	// Set whitelisted vault
	Instruction_SetWhitelistedVault = ag_binary.TypeID([8]byte{12, 148, 94, 42, 55, 57, 83, 247})

	// Partner claim fee
	Instruction_PartnerClaimFee = ag_binary.TypeID([8]byte{57, 53, 176, 30, 123, 70, 52, 64})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_InitializePermissionedPool:
		return "InitializePermissionedPool"
	case Instruction_InitializePermissionlessPool:
		return "InitializePermissionlessPool"
	case Instruction_InitializePermissionlessPoolWithFeeTier:
		return "InitializePermissionlessPoolWithFeeTier"
	case Instruction_EnableOrDisablePool:
		return "EnableOrDisablePool"
	case Instruction_Swap:
		return "Swap"
	case Instruction_RemoveLiquiditySingleSide:
		return "RemoveLiquiditySingleSide"
	case Instruction_AddImbalanceLiquidity:
		return "AddImbalanceLiquidity"
	case Instruction_RemoveBalanceLiquidity:
		return "RemoveBalanceLiquidity"
	case Instruction_AddBalanceLiquidity:
		return "AddBalanceLiquidity"
	case Instruction_SetPoolFees:
		return "SetPoolFees"
	case Instruction_OverrideCurveParam:
		return "OverrideCurveParam"
	case Instruction_GetPoolInfo:
		return "GetPoolInfo"
	case Instruction_BootstrapLiquidity:
		return "BootstrapLiquidity"
	case Instruction_CreateMintMetadata:
		return "CreateMintMetadata"
	case Instruction_CreateLockEscrow:
		return "CreateLockEscrow"
	case Instruction_Lock:
		return "Lock"
	case Instruction_ClaimFee:
		return "ClaimFee"
	case Instruction_CreateConfig:
		return "CreateConfig"
	case Instruction_CloseConfig:
		return "CloseConfig"
	case Instruction_InitializePermissionlessConstantProductPoolWithConfig:
		return "InitializePermissionlessConstantProductPoolWithConfig"
	case Instruction_InitializePermissionlessConstantProductPoolWithConfig2:
		return "InitializePermissionlessConstantProductPoolWithConfig2"
	case Instruction_InitializeCustomizablePermissionlessConstantProductPool:
		return "InitializeCustomizablePermissionlessConstantProductPool"
	case Instruction_UpdateActivationPoint:
		return "UpdateActivationPoint"
	case Instruction_WithdrawProtocolFees:
		return "WithdrawProtocolFees"
	case Instruction_SetWhitelistedVault:
		return "SetWhitelistedVault"
	case Instruction_PartnerClaimFee:
		return "PartnerClaimFee"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			Name: "initialize_permissioned_pool", Type: (*InitializePermissionedPool)(nil),
		},
		{
			Name: "initialize_permissionless_pool", Type: (*InitializePermissionlessPool)(nil),
		},
		{
			Name: "initialize_permissionless_pool_with_fee_tier", Type: (*InitializePermissionlessPoolWithFeeTier)(nil),
		},
		{
			Name: "enable_or_disable_pool", Type: (*EnableOrDisablePool)(nil),
		},
		{
			Name: "swap", Type: (*Swap)(nil),
		},
		{
			Name: "remove_liquidity_single_side", Type: (*RemoveLiquiditySingleSide)(nil),
		},
		{
			Name: "add_imbalance_liquidity", Type: (*AddImbalanceLiquidity)(nil),
		},
		{
			Name: "remove_balance_liquidity", Type: (*RemoveBalanceLiquidity)(nil),
		},
		{
			Name: "add_balance_liquidity", Type: (*AddBalanceLiquidity)(nil),
		},
		{
			Name: "set_pool_fees", Type: (*SetPoolFees)(nil),
		},
		{
			Name: "override_curve_param", Type: (*OverrideCurveParam)(nil),
		},
		{
			Name: "get_pool_info", Type: (*GetPoolInfo)(nil),
		},
		{
			Name: "bootstrap_liquidity", Type: (*BootstrapLiquidity)(nil),
		},
		{
			Name: "create_mint_metadata", Type: (*CreateMintMetadata)(nil),
		},
		{
			Name: "create_lock_escrow", Type: (*CreateLockEscrow)(nil),
		},
		{
			Name: "lock", Type: (*Lock)(nil),
		},
		{
			Name: "claim_fee", Type: (*ClaimFee)(nil),
		},
		{
			Name: "create_config", Type: (*CreateConfig)(nil),
		},
		{
			Name: "close_config", Type: (*CloseConfig)(nil),
		},
		{
			Name: "initialize_permissionless_constant_product_pool_with_config", Type: (*InitializePermissionlessConstantProductPoolWithConfig)(nil),
		},
		{
			Name: "initialize_permissionless_constant_product_pool_with_config2", Type: (*InitializePermissionlessConstantProductPoolWithConfig2)(nil),
		},
		{
			Name: "initialize_customizable_permissionless_constant_product_pool", Type: (*InitializeCustomizablePermissionlessConstantProductPool)(nil),
		},
		{
			Name: "update_activation_point", Type: (*UpdateActivationPoint)(nil),
		},
		{
			Name: "withdraw_protocol_fees", Type: (*WithdrawProtocolFees)(nil),
		},
		{
			Name: "set_whitelisted_vault", Type: (*SetWhitelistedVault)(nil),
		},
		{
			Name: "partner_claim_fee", Type: (*PartnerClaimFee)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := decodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func decodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
