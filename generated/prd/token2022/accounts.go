// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package token2022

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type MintAccount struct {
	// Optional authority used to mint new tokens. The mint authority may only be provided during
	// mint creation. If no mint authority is present then the mint has a fixed supply and no
	// further tokens may be minted.
	MintAuthority *ag_solanago.PublicKey `bin:"optional"`

	// Total supply of tokens.
	Supply uint64

	// Number of base 10 digits to the right of the decimal place.
	Decimals uint8

	// Is `true` if this structure has been initialized
	IsInitialized bool

	// Optional authority to freeze token accounts.
	FreezeAuthority *ag_solanago.PublicKey `bin:"optional"`
}

var MintAccountDiscriminator = [8]byte{0, 0, 0, 0, 0, 0, 0, 0}

func (obj MintAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(MintAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `MintAuthority` param (optional):
	{
		if obj.MintAuthority == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.MintAuthority)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Supply` param:
	err = encoder.Encode(obj.Supply)
	if err != nil {
		return err
	}
	// Serialize `Decimals` param:
	err = encoder.Encode(obj.Decimals)
	if err != nil {
		return err
	}
	// Serialize `IsInitialized` param:
	err = encoder.Encode(obj.IsInitialized)
	if err != nil {
		return err
	}
	// Serialize `FreezeAuthority` param (optional):
	{
		if obj.FreezeAuthority == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.FreezeAuthority)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *MintAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(MintAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[0 0 0 0 0 0 0 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `MintAuthority` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.MintAuthority)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Supply`:
	err = decoder.Decode(&obj.Supply)
	if err != nil {
		return err
	}
	// Deserialize `Decimals`:
	err = decoder.Decode(&obj.Decimals)
	if err != nil {
		return err
	}
	// Deserialize `IsInitialized`:
	err = decoder.Decode(&obj.IsInitialized)
	if err != nil {
		return err
	}
	// Deserialize `FreezeAuthority` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.FreezeAuthority)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type TokenAccount struct {
	// The mint associated with this account
	Mint ag_solanago.PublicKey

	// The owner of this account.
	Owner ag_solanago.PublicKey

	// The amount of tokens this account holds.
	Amount uint64

	// If `delegate` is `Some` then `delegated_amount` represents
	// the amount authorized by the delegate
	Delegate *ag_solanago.PublicKey `bin:"optional"`

	// The account's state
	State AccountState

	// If is_some, this is a native token, and the value logs the rent-exempt reserve. An Account
	// is required to be rent-exempt, so the value is used by the Processor to ensure that wrapped
	// SOL accounts do not drop below this threshold.
	IsNative *uint64 `bin:"optional"`

	// The amount delegated
	DelegatedAmount uint64

	// Optional authority to close the account.
	CloseAuthority *ag_solanago.PublicKey `bin:"optional"`
}

var TokenAccountDiscriminator = [8]byte{113, 66, 224, 54, 188, 119, 240, 101}

func (obj TokenAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(TokenAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	// Serialize `Owner` param:
	err = encoder.Encode(obj.Owner)
	if err != nil {
		return err
	}
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Delegate` param (optional):
	{
		if obj.Delegate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Delegate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `State` param:
	err = encoder.Encode(obj.State)
	if err != nil {
		return err
	}
	// Serialize `IsNative` param (optional):
	{
		if obj.IsNative == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.IsNative)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `DelegatedAmount` param:
	err = encoder.Encode(obj.DelegatedAmount)
	if err != nil {
		return err
	}
	// Serialize `CloseAuthority` param (optional):
	{
		if obj.CloseAuthority == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.CloseAuthority)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *TokenAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(TokenAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[113 66 224 54 188 119 240 101]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Owner`:
	err = decoder.Decode(&obj.Owner)
	if err != nil {
		return err
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Delegate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Delegate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return err
	}
	// Deserialize `IsNative` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.IsNative)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `DelegatedAmount`:
	err = decoder.Decode(&obj.DelegatedAmount)
	if err != nil {
		return err
	}
	// Deserialize `CloseAuthority` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.CloseAuthority)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type MultisigAccount struct {
	// Number of signers required
	M uint8

	// Number of valid signers
	N uint8

	// Is `true` if this structure has been initialized
	IsInitialized bool

	// Signer public keys
	Signers [11]ag_solanago.PublicKey
}

var MultisigAccountDiscriminator = [8]byte{0, 0, 0, 0, 0, 0, 0, 0}

func (obj MultisigAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(MultisigAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `M` param:
	err = encoder.Encode(obj.M)
	if err != nil {
		return err
	}
	// Serialize `N` param:
	err = encoder.Encode(obj.N)
	if err != nil {
		return err
	}
	// Serialize `IsInitialized` param:
	err = encoder.Encode(obj.IsInitialized)
	if err != nil {
		return err
	}
	// Serialize `Signers` param:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return err
	}
	return nil
}

func (obj *MultisigAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(MultisigAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[0 0 0 0 0 0 0 0]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `M`:
	err = decoder.Decode(&obj.M)
	if err != nil {
		return err
	}
	// Deserialize `N`:
	err = decoder.Decode(&obj.N)
	if err != nil {
		return err
	}
	// Deserialize `IsInitialized`:
	err = decoder.Decode(&obj.IsInitialized)
	if err != nil {
		return err
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return err
	}
	return nil
}
