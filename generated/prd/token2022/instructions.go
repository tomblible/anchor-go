// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package token2022

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

const ProgramName = "Token2022"

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

func SetProgramID(PublicKey ag_solanago.PublicKey) {
	ProgramID = PublicKey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var ()

var (
	// Initializes a new mint and optionally deposits all the newly minted
	// tokens in an account.
	//
	// The `InitializeMint` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeMint = ag_binary.TypeID([8]byte{209, 42, 195, 4, 129, 85, 209, 44})

	// Initializes a new account to hold tokens.  If this account is associated
	// with the native mint then the token balance of the initialized account
	// will be equal to the amount of SOL in the account. If this account is
	// associated with another mint, that mint must be initialized before this
	// command can succeed.
	//
	// The `InitializeAccount` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeAccount = ag_binary.TypeID([8]byte{74, 115, 99, 93, 197, 69, 103, 7})

	// Initializes a multisignature account with N provided signers.
	//
	// Multisignature accounts can used in place of any single owner/delegate
	// accounts in any token instruction that require an owner/delegate to be
	// present.  The variant field represents the number of signers (M)
	// required to validate this multisignature account.
	//
	// The `InitializeMultisig` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeMultisig = ag_binary.TypeID([8]byte{220, 130, 117, 21, 27, 227, 78, 213})

	// Transfers tokens from one account to another either directly or via a
	// delegate.  If this account is associated with the native mint then equal
	// amounts of SOL and Tokens will be transferred to the destination
	// account.
	Instruction_Transfer = ag_binary.TypeID([8]byte{163, 52, 200, 231, 140, 3, 69, 186})

	// Approves a delegate.  A delegate is given the authority over tokens on
	// behalf of the source account's owner.
	Instruction_Approve = ag_binary.TypeID([8]byte{69, 74, 217, 36, 115, 117, 97, 76})

	// Revokes the delegate's authority.
	Instruction_Revoke = ag_binary.TypeID([8]byte{170, 23, 31, 34, 133, 173, 93, 242})

	// Sets a new authority of a mint or account.
	Instruction_SetAuthority = ag_binary.TypeID([8]byte{133, 250, 37, 21, 110, 163, 26, 121})

	// Mints new tokens to an account.  The native mint does not support
	// minting.
	Instruction_MintTo = ag_binary.TypeID([8]byte{241, 34, 48, 186, 37, 179, 123, 192})

	// Burns tokens by removing them from an account.  `Burn` does not support
	// accounts associated with the native mint, use `CloseAccount` instead.
	Instruction_Burn = ag_binary.TypeID([8]byte{116, 110, 29, 56, 107, 219, 42, 93})

	// Close an account by transferring all its SOL to the destination account.
	// Non-native accounts may only be closed if its token amount is zero.
	Instruction_CloseAccount = ag_binary.TypeID([8]byte{125, 255, 149, 14, 110, 34, 72, 24})

	// Freeze an Initialized account using the Mint's freeze_authority (if set).
	Instruction_FreezeAccount = ag_binary.TypeID([8]byte{253, 75, 82, 133, 167, 238, 43, 130})

	// Thaw a Frozen account using the Mint's freeze_authority (if set).
	Instruction_ThawAccount = ag_binary.TypeID([8]byte{115, 152, 79, 213, 213, 169, 184, 35})

	// Transfers tokens from one account to another either directly or via a
	// delegate.  If this account is associated with the native mint then equal
	// amounts of SOL and Tokens will be transferred to the destination
	// account.
	//
	// This instruction differs from Transfer in that the token mint and
	// decimals value is checked by the caller.  This may be useful when
	// creating transactions offline or within a hardware wallet.
	Instruction_TransferChecked = ag_binary.TypeID([8]byte{119, 250, 202, 24, 253, 135, 244, 121})

	// Approves a delegate.  A delegate is given the authority over tokens on
	// behalf of the source account's owner.
	//
	// This instruction differs from Approve in that the token mint and
	// decimals value is checked by the caller.  This may be useful when
	// creating transactions offline or within a hardware wallet.
	Instruction_ApproveChecked = ag_binary.TypeID([8]byte{47, 197, 254, 42, 58, 201, 58, 109})

	// Mints new tokens to an account.  The native mint does not support minting.
	//
	// This instruction differs from MintTo in that the decimals value is
	// checked by the caller.  This may be useful when creating transactions
	// offline or within a hardware wallet.
	Instruction_MintToChecked = ag_binary.TypeID([8]byte{229, 236, 36, 240, 118, 225, 45, 125})

	// Burns tokens by removing them from an account.  `BurnChecked` does not
	// support accounts associated with the native mint, use `CloseAccount`
	// instead.
	//
	// This instruction differs from Burn in that the decimals value is checked
	// by the caller. This may be useful when creating transactions offline or
	// within a hardware wallet.
	Instruction_BurnChecked = ag_binary.TypeID([8]byte{198, 121, 200, 102, 120, 208, 155, 178})

	// Like InitializeAccount, but the owner pubkey is passed via instruction data
	// rather than the accounts list. This variant may be preferable when using
	// Cross Program Invocation from an instruction that does not need the owner's
	// `AccountInfo` otherwise.
	Instruction_InitializeAccount2 = ag_binary.TypeID([8]byte{8, 182, 149, 144, 185, 31, 209, 105})

	// Given a wrapped / native token account (a token account containing SOL)
	// updates its amount field based on the account's underlying `lamports`.
	// This is useful if a non-wrapped SOL account uses `system_instruction::transfer`
	// to move lamports to a wrapped token account, and needs to have its token
	// `amount` field updated.
	Instruction_SyncNative = ag_binary.TypeID([8]byte{155, 219, 36, 36, 239, 128, 21, 65})

	// Like InitializeAccount2, but does not require the Rent sysvar to be provided.
	Instruction_InitializeAccount3 = ag_binary.TypeID([8]byte{23, 142, 140, 135, 21, 160, 133, 64})

	// Like InitializeMultisig, but does not require the Rent sysvar to be provided.
	Instruction_InitializeMultisig2 = ag_binary.TypeID([8]byte{81, 239, 73, 39, 27, 148, 2, 146})

	// Like InitializeMint, but does not require the Rent sysvar to be provided.
	Instruction_InitializeMint2 = ag_binary.TypeID([8]byte{95, 108, 198, 210, 72, 243, 143, 235})

	// Gets the required size of an account for the given mint as a little-endian `u64`
	Instruction_GetAccountDataSize = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Initialize the Immutable Owner extension for the given token account
	Instruction_InitializeImmutableOwner = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Convert an Amount of tokens to a `UiAmount` string, using the given mint
	Instruction_AmountToUiAmount = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Convert a `UiAmount` of tokens to a little-endian `u64` raw Amount
	// using the given mint
	Instruction_UiAmountToAmount = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Initialize the close account authority on a new mint.
	Instruction_InitializeMintCloseAuthority = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for Transfer Fee extension instructions.
	Instruction_TransferFeeExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for Confidential Transfer extension.
	Instruction_ConfidentialTransferExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for Default Account State extension
	Instruction_DefaultAccountStateExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Check if a token account is large enough for a list of ExtensionTypes,
	// and if not, use reallocation to increase the data size.
	Instruction_Reallocate = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for Memo Transfer account extension instructions.
	Instruction_MemoTransferExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Creates the native mint.
	Instruction_CreateNativeMint = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Initialize the non transferable extension for the given mint account.
	Instruction_InitializeNonTransferableMint = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for Interest Bearing extension instructions.
	Instruction_InterestBearingMintExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for CPI Guard account extension instructions.
	Instruction_CpiGuardExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Initialize the permanent delegate on a new mint.
	Instruction_InitializePermanentDelegate = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for transfer hook extension instructions.
	Instruction_TransferHookExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for the confidential transfer fee extension instructions.
	Instruction_ConfidentialTransferFeeExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// This instruction is to be used to rescue SOL sent to any `TokenProgram`
	Instruction_WithdrawExcessLamports = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for metadata pointer extension instructions.
	Instruction_MetadataPointerExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for group pointer extension instructions.
	Instruction_GroupPointerExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// The common instruction prefix for group member pointer extension instructions.
	Instruction_GroupMemberPointerExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Instruction prefix for instructions to the confidential-mint-burn extension
	Instruction_ConfidentialMintBurnExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Instruction prefix for instructions to the scaled ui amount extension
	Instruction_ScaledUiAmountExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})

	// Instruction prefix for instructions to the pausable extension
	Instruction_PausableExtension = ag_binary.TypeID([8]byte{150, 200, 100, 50, 200, 150, 100, 50})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_InitializeMint:
		return "InitializeMint"
	case Instruction_InitializeAccount:
		return "InitializeAccount"
	case Instruction_InitializeMultisig:
		return "InitializeMultisig"
	case Instruction_Transfer:
		return "Transfer"
	case Instruction_Approve:
		return "Approve"
	case Instruction_Revoke:
		return "Revoke"
	case Instruction_SetAuthority:
		return "SetAuthority"
	case Instruction_MintTo:
		return "MintTo"
	case Instruction_Burn:
		return "Burn"
	case Instruction_CloseAccount:
		return "CloseAccount"
	case Instruction_FreezeAccount:
		return "FreezeAccount"
	case Instruction_ThawAccount:
		return "ThawAccount"
	case Instruction_TransferChecked:
		return "TransferChecked"
	case Instruction_ApproveChecked:
		return "ApproveChecked"
	case Instruction_MintToChecked:
		return "MintToChecked"
	case Instruction_BurnChecked:
		return "BurnChecked"
	case Instruction_InitializeAccount2:
		return "InitializeAccount2"
	case Instruction_SyncNative:
		return "SyncNative"
	case Instruction_InitializeAccount3:
		return "InitializeAccount3"
	case Instruction_InitializeMultisig2:
		return "InitializeMultisig2"
	case Instruction_InitializeMint2:
		return "InitializeMint2"
	case Instruction_GetAccountDataSize:
		return "GetAccountDataSize"
	case Instruction_InitializeImmutableOwner:
		return "InitializeImmutableOwner"
	case Instruction_AmountToUiAmount:
		return "AmountToUiAmount"
	case Instruction_UiAmountToAmount:
		return "UiAmountToAmount"
	case Instruction_InitializeMintCloseAuthority:
		return "InitializeMintCloseAuthority"
	case Instruction_TransferFeeExtension:
		return "TransferFeeExtension"
	case Instruction_ConfidentialTransferExtension:
		return "ConfidentialTransferExtension"
	case Instruction_DefaultAccountStateExtension:
		return "DefaultAccountStateExtension"
	case Instruction_Reallocate:
		return "Reallocate"
	case Instruction_MemoTransferExtension:
		return "MemoTransferExtension"
	case Instruction_CreateNativeMint:
		return "CreateNativeMint"
	case Instruction_InitializeNonTransferableMint:
		return "InitializeNonTransferableMint"
	case Instruction_InterestBearingMintExtension:
		return "InterestBearingMintExtension"
	case Instruction_CpiGuardExtension:
		return "CpiGuardExtension"
	case Instruction_InitializePermanentDelegate:
		return "InitializePermanentDelegate"
	case Instruction_TransferHookExtension:
		return "TransferHookExtension"
	case Instruction_ConfidentialTransferFeeExtension:
		return "ConfidentialTransferFeeExtension"
	case Instruction_WithdrawExcessLamports:
		return "WithdrawExcessLamports"
	case Instruction_MetadataPointerExtension:
		return "MetadataPointerExtension"
	case Instruction_GroupPointerExtension:
		return "GroupPointerExtension"
	case Instruction_GroupMemberPointerExtension:
		return "GroupMemberPointerExtension"
	case Instruction_ConfidentialMintBurnExtension:
		return "ConfidentialMintBurnExtension"
	case Instruction_ScaledUiAmountExtension:
		return "ScaledUiAmountExtension"
	case Instruction_PausableExtension:
		return "PausableExtension"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			Name: "initialize_mint", Type: (*InitializeMint)(nil),
		},
		{
			Name: "initialize_account", Type: (*InitializeAccount)(nil),
		},
		{
			Name: "initialize_multisig", Type: (*InitializeMultisig)(nil),
		},
		{
			Name: "transfer", Type: (*Transfer)(nil),
		},
		{
			Name: "approve", Type: (*Approve)(nil),
		},
		{
			Name: "revoke", Type: (*Revoke)(nil),
		},
		{
			Name: "set_authority", Type: (*SetAuthority)(nil),
		},
		{
			Name: "mint_to", Type: (*MintTo)(nil),
		},
		{
			Name: "burn", Type: (*Burn)(nil),
		},
		{
			Name: "close_account", Type: (*CloseAccount)(nil),
		},
		{
			Name: "freeze_account", Type: (*FreezeAccount)(nil),
		},
		{
			Name: "thaw_account", Type: (*ThawAccount)(nil),
		},
		{
			Name: "transfer_checked", Type: (*TransferChecked)(nil),
		},
		{
			Name: "approve_checked", Type: (*ApproveChecked)(nil),
		},
		{
			Name: "mint_to_checked", Type: (*MintToChecked)(nil),
		},
		{
			Name: "burn_checked", Type: (*BurnChecked)(nil),
		},
		{
			Name: "initialize_account2", Type: (*InitializeAccount2)(nil),
		},
		{
			Name: "sync_native", Type: (*SyncNative)(nil),
		},
		{
			Name: "initialize_account3", Type: (*InitializeAccount3)(nil),
		},
		{
			Name: "initialize_multisig2", Type: (*InitializeMultisig2)(nil),
		},
		{
			Name: "initialize_mint2", Type: (*InitializeMint2)(nil),
		},
		{
			Name: "get_account_data_size", Type: (*GetAccountDataSize)(nil),
		},
		{
			Name: "initialize_immutable_owner", Type: (*InitializeImmutableOwner)(nil),
		},
		{
			Name: "amount_to_ui_amount", Type: (*AmountToUiAmount)(nil),
		},
		{
			Name: "ui_amount_to_amount", Type: (*UiAmountToAmount)(nil),
		},
		{
			Name: "initialize_mint_close_authority", Type: (*InitializeMintCloseAuthority)(nil),
		},
		{
			Name: "transfer_fee_extension", Type: (*TransferFeeExtension)(nil),
		},
		{
			Name: "confidential_transfer_extension", Type: (*ConfidentialTransferExtension)(nil),
		},
		{
			Name: "default_account_state_extension", Type: (*DefaultAccountStateExtension)(nil),
		},
		{
			Name: "reallocate", Type: (*Reallocate)(nil),
		},
		{
			Name: "memo_transfer_extension", Type: (*MemoTransferExtension)(nil),
		},
		{
			Name: "create_native_mint", Type: (*CreateNativeMint)(nil),
		},
		{
			Name: "initialize_non_transferable_mint", Type: (*InitializeNonTransferableMint)(nil),
		},
		{
			Name: "interest_bearing_mint_extension", Type: (*InterestBearingMintExtension)(nil),
		},
		{
			Name: "cpi_guard_extension", Type: (*CpiGuardExtension)(nil),
		},
		{
			Name: "initialize_permanent_delegate", Type: (*InitializePermanentDelegate)(nil),
		},
		{
			Name: "transfer_hook_extension", Type: (*TransferHookExtension)(nil),
		},
		{
			Name: "confidential_transfer_fee_extension", Type: (*ConfidentialTransferFeeExtension)(nil),
		},
		{
			Name: "withdraw_excess_lamports", Type: (*WithdrawExcessLamports)(nil),
		},
		{
			Name: "metadata_pointer_extension", Type: (*MetadataPointerExtension)(nil),
		},
		{
			Name: "group_pointer_extension", Type: (*GroupPointerExtension)(nil),
		},
		{
			Name: "group_member_pointer_extension", Type: (*GroupMemberPointerExtension)(nil),
		},
		{
			Name: "confidential_mint_burn_extension", Type: (*ConfidentialMintBurnExtension)(nil),
		},
		{
			Name: "scaled_ui_amount_extension", Type: (*ScaledUiAmountExtension)(nil),
		},
		{
			Name: "pausable_extension", Type: (*PausableExtension)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := decodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func decodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
