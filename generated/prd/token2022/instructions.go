// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package token2022

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

const ProgramName = "Token2022"

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

func SetProgramID(PublicKey ag_solanago.PublicKey) {
	ProgramID = PublicKey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var ()

const (
	// Initializes a new mint and optionally deposits all the newly minted
	// tokens in an account.
	//
	// The `InitializeMint` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeMint uint8 = iota

	// Initializes a new account to hold tokens.  If this account is associated
	// with the native mint then the token balance of the initialized account
	// will be equal to the amount of SOL in the account. If this account is
	// associated with another mint, that mint must be initialized before this
	// command can succeed.
	//
	// The `InitializeAccount` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeAccount

	// Initializes a multisignature account with N provided signers.
	//
	// Multisignature accounts can used in place of any single owner/delegate
	// accounts in any token instruction that require an owner/delegate to be
	// present.  The variant field represents the number of signers (M)
	// required to validate this multisignature account.
	//
	// The `InitializeMultisig` instruction requires no signers and MUST be
	// included within the same Transaction as the system program's
	// `CreateAccount` instruction that creates the account being initialized.
	// Otherwise another party can acquire ownership of the uninitialized
	// account.
	Instruction_InitializeMultisig

	// Transfers tokens from one account to another either directly or via a
	// delegate.  If this account is associated with the native mint then equal
	// amounts of SOL and Tokens will be transferred to the destination
	// account.
	Instruction_Transfer

	// Approves a delegate.  A delegate is given the authority over tokens on
	// behalf of the source account's owner.
	Instruction_Approve

	// Revokes the delegate's authority.
	Instruction_Revoke

	// Sets a new authority of a mint or account.
	Instruction_SetAuthority

	// Mints new tokens to an account.  The native mint does not support
	// minting.
	Instruction_MintTo

	// Burns tokens by removing them from an account.  `Burn` does not support
	// accounts associated with the native mint, use `CloseAccount` instead.
	Instruction_Burn

	// Close an account by transferring all its SOL to the destination account.
	// Non-native accounts may only be closed if its token amount is zero.
	Instruction_CloseAccount

	// Freeze an Initialized account using the Mint's freeze_authority (if set).
	Instruction_FreezeAccount

	// Thaw a Frozen account using the Mint's freeze_authority (if set).
	Instruction_ThawAccount

	// Transfers tokens from one account to another either directly or via a
	// delegate.  If this account is associated with the native mint then equal
	// amounts of SOL and Tokens will be transferred to the destination
	// account.
	//
	// This instruction differs from Transfer in that the token mint and
	// decimals value is checked by the caller.  This may be useful when
	// creating transactions offline or within a hardware wallet.
	Instruction_TransferChecked

	// Approves a delegate.  A delegate is given the authority over tokens on
	// behalf of the source account's owner.
	//
	// This instruction differs from Approve in that the token mint and
	// decimals value is checked by the caller.  This may be useful when
	// creating transactions offline or within a hardware wallet.
	Instruction_ApproveChecked

	// Mints new tokens to an account.  The native mint does not support minting.
	//
	// This instruction differs from MintTo in that the decimals value is
	// checked by the caller.  This may be useful when creating transactions
	// offline or within a hardware wallet.
	Instruction_MintToChecked

	// Burns tokens by removing them from an account.  `BurnChecked` does not
	// support accounts associated with the native mint, use `CloseAccount`
	// instead.
	//
	// This instruction differs from Burn in that the decimals value is checked
	// by the caller. This may be useful when creating transactions offline or
	// within a hardware wallet.
	Instruction_BurnChecked

	// Like InitializeAccount, but the owner pubkey is passed via instruction data
	// rather than the accounts list. This variant may be preferable when using
	// Cross Program Invocation from an instruction that does not need the owner's
	// `AccountInfo` otherwise.
	Instruction_InitializeAccount2

	// Given a wrapped / native token account (a token account containing SOL)
	// updates its amount field based on the account's underlying `lamports`.
	// This is useful if a non-wrapped SOL account uses `system_instruction::transfer`
	// to move lamports to a wrapped token account, and needs to have its token
	// `amount` field updated.
	Instruction_SyncNative

	// Like InitializeAccount2, but does not require the Rent sysvar to be provided.
	Instruction_InitializeAccount3

	// Like InitializeMultisig, but does not require the Rent sysvar to be provided.
	Instruction_InitializeMultisig2

	// Like InitializeMint, but does not require the Rent sysvar to be provided.
	Instruction_InitializeMint2

	// Gets the required size of an account for the given mint as a little-endian `u64`
	Instruction_GetAccountDataSize

	// Initialize the Immutable Owner extension for the given token account
	Instruction_InitializeImmutableOwner

	// Convert an Amount of tokens to a `UiAmount` string, using the given mint
	Instruction_AmountToUiAmount

	// Convert a `UiAmount` of tokens to a little-endian `u64` raw Amount
	// using the given mint
	Instruction_UiAmountToAmount

	// Initialize the close account authority on a new mint.
	Instruction_InitializeMintCloseAuthority

	Instruction_InitializeTransferFeeConfig

	Instruction_TransferCheckedWithFee

	Instruction_WithdrawWithheldTokensFromMint

	Instruction_WithdrawWithheldTokensFromAccounts

	Instruction_HarvestWithheldTokensToMint

	Instruction_SetTransferFee

	Instruction_InitializeConfidentialTransferMint

	Instruction_UpdateConfidentialTransferMint

	Instruction_ConfigureConfidentialTransferAccount

	Instruction_ApproveConfidentialTransferAccount

	Instruction_EmptyConfidentialTransferAccount

	Instruction_ConfidentialDeposit

	Instruction_ConfidentialWithdraw

	Instruction_ConfidentialTransfer

	Instruction_ApplyConfidentialPendingBalance

	Instruction_EnableConfidentialCredits

	Instruction_DisableConfidentialCredits

	Instruction_EnableNonConfidentialCredits

	Instruction_DisableNonConfidentialCredits

	Instruction_ConfidentialTransferWithFee

	Instruction_ConfigureAccountWithRegistry

	Instruction_InitializeDefaultAccountState

	Instruction_UpdateDefaultAccountState

	// Check if a token account is large enough for a list of ExtensionTypes,
	// and if not, use reallocation to increase the data size.
	Instruction_Reallocate

	Instruction_EnableMemoTransfers

	Instruction_DisableMemoTransfers

	// Creates the native mint.
	Instruction_CreateNativeMint

	// Initialize the non transferable extension for the given mint account.
	Instruction_InitializeNonTransferableMint

	Instruction_InitializeInterestBearingMint

	Instruction_UpdateRateInterestBearingMint

	Instruction_EnableCpiGuard

	Instruction_DisableCpiGuard

	// Initialize the permanent delegate on a new mint.
	Instruction_InitializePermanentDelegate

	Instruction_InitializeTransferHook

	Instruction_UpdateTransferHook

	Instruction_InitializeConfidentialTransferFee

	Instruction_WithdrawWithheldTokensFromMintForConfidentialTransferFee

	Instruction_WithdrawWithheldTokensFromAccountsForConfidentialTransferFee

	Instruction_HarvestWithheldTokensToMintForConfidentialTransferFee

	Instruction_EnableHarvestToMint

	Instruction_DisableHarvestToMint

	// This instruction is to be used to rescue SOL sent to any `TokenProgram`
	Instruction_WithdrawExcessLamports

	Instruction_InitializeMetadataPointer

	Instruction_UpdateMetadataPointer

	Instruction_InitializeGroupPointer

	Instruction_UpdateGroupPointer

	Instruction_InitializeGroupMemberPointer

	Instruction_UpdateGroupMemberPointer

	Instruction_InitializeConfidentialMintBurn

	Instruction_RotateSupplyElgamalPubkey

	Instruction_UpdateDecryptableSupply

	Instruction_MintToken

	Instruction_BurnToken

	Instruction_ApplyPendingBurn

	Instruction_InitializeScaledUiAmountMint

	Instruction_UpdateMultiplierScaledUiMint

	Instruction_InitializePausableConfig

	Instruction_Pause

	Instruction_Resume
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id uint8) string {
	switch id {
	case Instruction_InitializeMint:
		return "InitializeMint"
	case Instruction_InitializeAccount:
		return "InitializeAccount"
	case Instruction_InitializeMultisig:
		return "InitializeMultisig"
	case Instruction_Transfer:
		return "Transfer"
	case Instruction_Approve:
		return "Approve"
	case Instruction_Revoke:
		return "Revoke"
	case Instruction_SetAuthority:
		return "SetAuthority"
	case Instruction_MintTo:
		return "MintTo"
	case Instruction_Burn:
		return "Burn"
	case Instruction_CloseAccount:
		return "CloseAccount"
	case Instruction_FreezeAccount:
		return "FreezeAccount"
	case Instruction_ThawAccount:
		return "ThawAccount"
	case Instruction_TransferChecked:
		return "TransferChecked"
	case Instruction_ApproveChecked:
		return "ApproveChecked"
	case Instruction_MintToChecked:
		return "MintToChecked"
	case Instruction_BurnChecked:
		return "BurnChecked"
	case Instruction_InitializeAccount2:
		return "InitializeAccount2"
	case Instruction_SyncNative:
		return "SyncNative"
	case Instruction_InitializeAccount3:
		return "InitializeAccount3"
	case Instruction_InitializeMultisig2:
		return "InitializeMultisig2"
	case Instruction_InitializeMint2:
		return "InitializeMint2"
	case Instruction_GetAccountDataSize:
		return "GetAccountDataSize"
	case Instruction_InitializeImmutableOwner:
		return "InitializeImmutableOwner"
	case Instruction_AmountToUiAmount:
		return "AmountToUiAmount"
	case Instruction_UiAmountToAmount:
		return "UiAmountToAmount"
	case Instruction_InitializeMintCloseAuthority:
		return "InitializeMintCloseAuthority"
	case Instruction_InitializeTransferFeeConfig:
		return "InitializeTransferFeeConfig"
	case Instruction_TransferCheckedWithFee:
		return "TransferCheckedWithFee"
	case Instruction_WithdrawWithheldTokensFromMint:
		return "WithdrawWithheldTokensFromMint"
	case Instruction_WithdrawWithheldTokensFromAccounts:
		return "WithdrawWithheldTokensFromAccounts"
	case Instruction_HarvestWithheldTokensToMint:
		return "HarvestWithheldTokensToMint"
	case Instruction_SetTransferFee:
		return "SetTransferFee"
	case Instruction_InitializeConfidentialTransferMint:
		return "InitializeConfidentialTransferMint"
	case Instruction_UpdateConfidentialTransferMint:
		return "UpdateConfidentialTransferMint"
	case Instruction_ConfigureConfidentialTransferAccount:
		return "ConfigureConfidentialTransferAccount"
	case Instruction_ApproveConfidentialTransferAccount:
		return "ApproveConfidentialTransferAccount"
	case Instruction_EmptyConfidentialTransferAccount:
		return "EmptyConfidentialTransferAccount"
	case Instruction_ConfidentialDeposit:
		return "ConfidentialDeposit"
	case Instruction_ConfidentialWithdraw:
		return "ConfidentialWithdraw"
	case Instruction_ConfidentialTransfer:
		return "ConfidentialTransfer"
	case Instruction_ApplyConfidentialPendingBalance:
		return "ApplyConfidentialPendingBalance"
	case Instruction_EnableConfidentialCredits:
		return "EnableConfidentialCredits"
	case Instruction_DisableConfidentialCredits:
		return "DisableConfidentialCredits"
	case Instruction_EnableNonConfidentialCredits:
		return "EnableNonConfidentialCredits"
	case Instruction_DisableNonConfidentialCredits:
		return "DisableNonConfidentialCredits"
	case Instruction_ConfidentialTransferWithFee:
		return "ConfidentialTransferWithFee"
	case Instruction_ConfigureAccountWithRegistry:
		return "ConfigureAccountWithRegistry"
	case Instruction_InitializeDefaultAccountState:
		return "InitializeDefaultAccountState"
	case Instruction_UpdateDefaultAccountState:
		return "UpdateDefaultAccountState"
	case Instruction_Reallocate:
		return "Reallocate"
	case Instruction_EnableMemoTransfers:
		return "EnableMemoTransfers"
	case Instruction_DisableMemoTransfers:
		return "DisableMemoTransfers"
	case Instruction_CreateNativeMint:
		return "CreateNativeMint"
	case Instruction_InitializeNonTransferableMint:
		return "InitializeNonTransferableMint"
	case Instruction_InitializeInterestBearingMint:
		return "InitializeInterestBearingMint"
	case Instruction_UpdateRateInterestBearingMint:
		return "UpdateRateInterestBearingMint"
	case Instruction_EnableCpiGuard:
		return "EnableCpiGuard"
	case Instruction_DisableCpiGuard:
		return "DisableCpiGuard"
	case Instruction_InitializePermanentDelegate:
		return "InitializePermanentDelegate"
	case Instruction_InitializeTransferHook:
		return "InitializeTransferHook"
	case Instruction_UpdateTransferHook:
		return "UpdateTransferHook"
	case Instruction_InitializeConfidentialTransferFee:
		return "InitializeConfidentialTransferFee"
	case Instruction_WithdrawWithheldTokensFromMintForConfidentialTransferFee:
		return "WithdrawWithheldTokensFromMintForConfidentialTransferFee"
	case Instruction_WithdrawWithheldTokensFromAccountsForConfidentialTransferFee:
		return "WithdrawWithheldTokensFromAccountsForConfidentialTransferFee"
	case Instruction_HarvestWithheldTokensToMintForConfidentialTransferFee:
		return "HarvestWithheldTokensToMintForConfidentialTransferFee"
	case Instruction_EnableHarvestToMint:
		return "EnableHarvestToMint"
	case Instruction_DisableHarvestToMint:
		return "DisableHarvestToMint"
	case Instruction_WithdrawExcessLamports:
		return "WithdrawExcessLamports"
	case Instruction_InitializeMetadataPointer:
		return "InitializeMetadataPointer"
	case Instruction_UpdateMetadataPointer:
		return "UpdateMetadataPointer"
	case Instruction_InitializeGroupPointer:
		return "InitializeGroupPointer"
	case Instruction_UpdateGroupPointer:
		return "UpdateGroupPointer"
	case Instruction_InitializeGroupMemberPointer:
		return "InitializeGroupMemberPointer"
	case Instruction_UpdateGroupMemberPointer:
		return "UpdateGroupMemberPointer"
	case Instruction_InitializeConfidentialMintBurn:
		return "InitializeConfidentialMintBurn"
	case Instruction_RotateSupplyElgamalPubkey:
		return "RotateSupplyElgamalPubkey"
	case Instruction_UpdateDecryptableSupply:
		return "UpdateDecryptableSupply"
	case Instruction_MintToken:
		return "MintToken"
	case Instruction_BurnToken:
		return "BurnToken"
	case Instruction_ApplyPendingBurn:
		return "ApplyPendingBurn"
	case Instruction_InitializeScaledUiAmountMint:
		return "InitializeScaledUiAmountMint"
	case Instruction_UpdateMultiplierScaledUiMint:
		return "UpdateMultiplierScaledUiMint"
	case Instruction_InitializePausableConfig:
		return "InitializePausableConfig"
	case Instruction_Pause:
		return "Pause"
	case Instruction_Resume:
		return "Resume"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.Uint8TypeIDEncoding,
	[]ag_binary.VariantType{
		{
			Name: "InitializeMint", Type: (*InitializeMint)(nil),
		},
		{
			Name: "InitializeAccount", Type: (*InitializeAccount)(nil),
		},
		{
			Name: "InitializeMultisig", Type: (*InitializeMultisig)(nil),
		},
		{
			Name: "Transfer", Type: (*Transfer)(nil),
		},
		{
			Name: "Approve", Type: (*Approve)(nil),
		},
		{
			Name: "Revoke", Type: (*Revoke)(nil),
		},
		{
			Name: "SetAuthority", Type: (*SetAuthority)(nil),
		},
		{
			Name: "MintTo", Type: (*MintTo)(nil),
		},
		{
			Name: "Burn", Type: (*Burn)(nil),
		},
		{
			Name: "CloseAccount", Type: (*CloseAccount)(nil),
		},
		{
			Name: "FreezeAccount", Type: (*FreezeAccount)(nil),
		},
		{
			Name: "ThawAccount", Type: (*ThawAccount)(nil),
		},
		{
			Name: "TransferChecked", Type: (*TransferChecked)(nil),
		},
		{
			Name: "ApproveChecked", Type: (*ApproveChecked)(nil),
		},
		{
			Name: "MintToChecked", Type: (*MintToChecked)(nil),
		},
		{
			Name: "BurnChecked", Type: (*BurnChecked)(nil),
		},
		{
			Name: "InitializeAccount2", Type: (*InitializeAccount2)(nil),
		},
		{
			Name: "SyncNative", Type: (*SyncNative)(nil),
		},
		{
			Name: "InitializeAccount3", Type: (*InitializeAccount3)(nil),
		},
		{
			Name: "InitializeMultisig2", Type: (*InitializeMultisig2)(nil),
		},
		{
			Name: "InitializeMint2", Type: (*InitializeMint2)(nil),
		},
		{
			Name: "GetAccountDataSize", Type: (*GetAccountDataSize)(nil),
		},
		{
			Name: "InitializeImmutableOwner", Type: (*InitializeImmutableOwner)(nil),
		},
		{
			Name: "AmountToUiAmount", Type: (*AmountToUiAmount)(nil),
		},
		{
			Name: "UiAmountToAmount", Type: (*UiAmountToAmount)(nil),
		},
		{
			Name: "InitializeMintCloseAuthority", Type: (*InitializeMintCloseAuthority)(nil),
		},
		{
			Name: "InitializeTransferFeeConfig", Type: (*InitializeTransferFeeConfig)(nil),
		},
		{
			Name: "TransferCheckedWithFee", Type: (*TransferCheckedWithFee)(nil),
		},
		{
			Name: "WithdrawWithheldTokensFromMint", Type: (*WithdrawWithheldTokensFromMint)(nil),
		},
		{
			Name: "WithdrawWithheldTokensFromAccounts", Type: (*WithdrawWithheldTokensFromAccounts)(nil),
		},
		{
			Name: "HarvestWithheldTokensToMint", Type: (*HarvestWithheldTokensToMint)(nil),
		},
		{
			Name: "SetTransferFee", Type: (*SetTransferFee)(nil),
		},
		{
			Name: "InitializeConfidentialTransferMint", Type: (*InitializeConfidentialTransferMint)(nil),
		},
		{
			Name: "UpdateConfidentialTransferMint", Type: (*UpdateConfidentialTransferMint)(nil),
		},
		{
			Name: "ConfigureConfidentialTransferAccount", Type: (*ConfigureConfidentialTransferAccount)(nil),
		},
		{
			Name: "ApproveConfidentialTransferAccount", Type: (*ApproveConfidentialTransferAccount)(nil),
		},
		{
			Name: "EmptyConfidentialTransferAccount", Type: (*EmptyConfidentialTransferAccount)(nil),
		},
		{
			Name: "ConfidentialDeposit", Type: (*ConfidentialDeposit)(nil),
		},
		{
			Name: "ConfidentialWithdraw", Type: (*ConfidentialWithdraw)(nil),
		},
		{
			Name: "ConfidentialTransfer", Type: (*ConfidentialTransfer)(nil),
		},
		{
			Name: "ApplyConfidentialPendingBalance", Type: (*ApplyConfidentialPendingBalance)(nil),
		},
		{
			Name: "EnableConfidentialCredits", Type: (*EnableConfidentialCredits)(nil),
		},
		{
			Name: "DisableConfidentialCredits", Type: (*DisableConfidentialCredits)(nil),
		},
		{
			Name: "EnableNonConfidentialCredits", Type: (*EnableNonConfidentialCredits)(nil),
		},
		{
			Name: "DisableNonConfidentialCredits", Type: (*DisableNonConfidentialCredits)(nil),
		},
		{
			Name: "ConfidentialTransferWithFee", Type: (*ConfidentialTransferWithFee)(nil),
		},
		{
			Name: "ConfigureAccountWithRegistry", Type: (*ConfigureAccountWithRegistry)(nil),
		},
		{
			Name: "InitializeDefaultAccountState", Type: (*InitializeDefaultAccountState)(nil),
		},
		{
			Name: "UpdateDefaultAccountState", Type: (*UpdateDefaultAccountState)(nil),
		},
		{
			Name: "Reallocate", Type: (*Reallocate)(nil),
		},
		{
			Name: "EnableMemoTransfers", Type: (*EnableMemoTransfers)(nil),
		},
		{
			Name: "DisableMemoTransfers", Type: (*DisableMemoTransfers)(nil),
		},
		{
			Name: "CreateNativeMint", Type: (*CreateNativeMint)(nil),
		},
		{
			Name: "InitializeNonTransferableMint", Type: (*InitializeNonTransferableMint)(nil),
		},
		{
			Name: "InitializeInterestBearingMint", Type: (*InitializeInterestBearingMint)(nil),
		},
		{
			Name: "UpdateRateInterestBearingMint", Type: (*UpdateRateInterestBearingMint)(nil),
		},
		{
			Name: "EnableCpiGuard", Type: (*EnableCpiGuard)(nil),
		},
		{
			Name: "DisableCpiGuard", Type: (*DisableCpiGuard)(nil),
		},
		{
			Name: "InitializePermanentDelegate", Type: (*InitializePermanentDelegate)(nil),
		},
		{
			Name: "InitializeTransferHook", Type: (*InitializeTransferHook)(nil),
		},
		{
			Name: "UpdateTransferHook", Type: (*UpdateTransferHook)(nil),
		},
		{
			Name: "InitializeConfidentialTransferFee", Type: (*InitializeConfidentialTransferFee)(nil),
		},
		{
			Name: "WithdrawWithheldTokensFromMintForConfidentialTransferFee", Type: (*WithdrawWithheldTokensFromMintForConfidentialTransferFee)(nil),
		},
		{
			Name: "WithdrawWithheldTokensFromAccountsForConfidentialTransferFee", Type: (*WithdrawWithheldTokensFromAccountsForConfidentialTransferFee)(nil),
		},
		{
			Name: "HarvestWithheldTokensToMintForConfidentialTransferFee", Type: (*HarvestWithheldTokensToMintForConfidentialTransferFee)(nil),
		},
		{
			Name: "EnableHarvestToMint", Type: (*EnableHarvestToMint)(nil),
		},
		{
			Name: "DisableHarvestToMint", Type: (*DisableHarvestToMint)(nil),
		},
		{
			Name: "WithdrawExcessLamports", Type: (*WithdrawExcessLamports)(nil),
		},
		{
			Name: "InitializeMetadataPointer", Type: (*InitializeMetadataPointer)(nil),
		},
		{
			Name: "UpdateMetadataPointer", Type: (*UpdateMetadataPointer)(nil),
		},
		{
			Name: "InitializeGroupPointer", Type: (*InitializeGroupPointer)(nil),
		},
		{
			Name: "UpdateGroupPointer", Type: (*UpdateGroupPointer)(nil),
		},
		{
			Name: "InitializeGroupMemberPointer", Type: (*InitializeGroupMemberPointer)(nil),
		},
		{
			Name: "UpdateGroupMemberPointer", Type: (*UpdateGroupMemberPointer)(nil),
		},
		{
			Name: "InitializeConfidentialMintBurn", Type: (*InitializeConfidentialMintBurn)(nil),
		},
		{
			Name: "RotateSupplyElgamalPubkey", Type: (*RotateSupplyElgamalPubkey)(nil),
		},
		{
			Name: "UpdateDecryptableSupply", Type: (*UpdateDecryptableSupply)(nil),
		},
		{
			Name: "MintToken", Type: (*MintToken)(nil),
		},
		{
			Name: "BurnToken", Type: (*BurnToken)(nil),
		},
		{
			Name: "ApplyPendingBurn", Type: (*ApplyPendingBurn)(nil),
		},
		{
			Name: "InitializeScaledUiAmountMint", Type: (*InitializeScaledUiAmountMint)(nil),
		},
		{
			Name: "UpdateMultiplierScaledUiMint", Type: (*UpdateMultiplierScaledUiMint)(nil),
		},
		{
			Name: "InitializePausableConfig", Type: (*InitializePausableConfig)(nil),
		},
		{
			Name: "Pause", Type: (*Pause)(nil),
		},
		{
			Name: "Resume", Type: (*Resume)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteUint8(inst.TypeID.Uint8())
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := decodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func decodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
