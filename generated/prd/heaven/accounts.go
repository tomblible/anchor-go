// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package heaven

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type LiquidityPoolStateAccount struct {
	Info                                                        LiquidityPoolInfo
	MarketCapBasedFees                                          LiquidityPoolMarketCapBasedFees
	Reserve                                                     LiquidityPoolReserve
	LpToken                                                     LiquidityPoolLpTokenInfo
	ProtocolTradingFees                                         uint64
	CreatorTradingFees                                          uint64
	CreatorTradingFeesClaimedByCreator                          uint64
	CreatorTradingFeesClaimedByOthers                           uint64
	LiquidityProviderTradingFees                                uint64
	CreatorTradingFeeProtocolFees                               uint64
	ReflectionTradingFees                                       uint64
	CreatedAtSlot                                               uint64
	TradingVolumeUsd                                            float64
	CreatorTradingFeeTradingVolumeThreshold                     float64
	CreatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp uint64
	TokenAVault                                                 ag_solanago.PublicKey
	TokenBVault                                                 ag_solanago.PublicKey
	ProtocolConfig                                              ag_solanago.PublicKey
	Key                                                         ag_solanago.PublicKey
	TokenA                                                      LiquidityPoolTokenInfo
	TokenB                                                      LiquidityPoolTokenInfo
	Allowlist                                                   LiquidityPoolAllowlist
	FeatureFlags                                                LiquidityPoolFeatureFlags
	TaxableSide                                                 uint8
	TaxableSideType                                             uint8
	CreatorTradingFeeDistribution                               uint8
	CreatorTradingFeeClaimStatus                                uint8
	FeeConfigurationMode                                        uint8
	IsMigrated                                                  uint8
	Pad                                                         [13]uint8
	SlotOffsetBasedFees                                         LiquidityPoolSlotOffsetBasedFees
	CreatorTradingFeeReceiver                                   ag_solanago.PublicKey
}

var LiquidityPoolStateAccountDiscriminator = [8]byte{190, 158, 220, 130, 15, 162, 132, 252}

func (obj LiquidityPoolStateAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(LiquidityPoolStateAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Info` param:
	err = encoder.Encode(obj.Info)
	if err != nil {
		return err
	}
	// Serialize `MarketCapBasedFees` param:
	err = encoder.Encode(obj.MarketCapBasedFees)
	if err != nil {
		return err
	}
	// Serialize `Reserve` param:
	err = encoder.Encode(obj.Reserve)
	if err != nil {
		return err
	}
	// Serialize `LpToken` param:
	err = encoder.Encode(obj.LpToken)
	if err != nil {
		return err
	}
	// Serialize `ProtocolTradingFees` param:
	err = encoder.Encode(obj.ProtocolTradingFees)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFees` param:
	err = encoder.Encode(obj.CreatorTradingFees)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeesClaimedByCreator` param:
	err = encoder.Encode(obj.CreatorTradingFeesClaimedByCreator)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeesClaimedByOthers` param:
	err = encoder.Encode(obj.CreatorTradingFeesClaimedByOthers)
	if err != nil {
		return err
	}
	// Serialize `LiquidityProviderTradingFees` param:
	err = encoder.Encode(obj.LiquidityProviderTradingFees)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeProtocolFees` param:
	err = encoder.Encode(obj.CreatorTradingFeeProtocolFees)
	if err != nil {
		return err
	}
	// Serialize `ReflectionTradingFees` param:
	err = encoder.Encode(obj.ReflectionTradingFees)
	if err != nil {
		return err
	}
	// Serialize `CreatedAtSlot` param:
	err = encoder.Encode(obj.CreatedAtSlot)
	if err != nil {
		return err
	}
	// Serialize `TradingVolumeUsd` param:
	err = encoder.Encode(obj.TradingVolumeUsd)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeTradingVolumeThreshold` param:
	err = encoder.Encode(obj.CreatorTradingFeeTradingVolumeThreshold)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp` param:
	err = encoder.Encode(obj.CreatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp)
	if err != nil {
		return err
	}
	// Serialize `TokenAVault` param:
	err = encoder.Encode(obj.TokenAVault)
	if err != nil {
		return err
	}
	// Serialize `TokenBVault` param:
	err = encoder.Encode(obj.TokenBVault)
	if err != nil {
		return err
	}
	// Serialize `ProtocolConfig` param:
	err = encoder.Encode(obj.ProtocolConfig)
	if err != nil {
		return err
	}
	// Serialize `Key` param:
	err = encoder.Encode(obj.Key)
	if err != nil {
		return err
	}
	// Serialize `TokenA` param:
	err = encoder.Encode(obj.TokenA)
	if err != nil {
		return err
	}
	// Serialize `TokenB` param:
	err = encoder.Encode(obj.TokenB)
	if err != nil {
		return err
	}
	// Serialize `Allowlist` param:
	err = encoder.Encode(obj.Allowlist)
	if err != nil {
		return err
	}
	// Serialize `FeatureFlags` param:
	err = encoder.Encode(obj.FeatureFlags)
	if err != nil {
		return err
	}
	// Serialize `TaxableSide` param:
	err = encoder.Encode(obj.TaxableSide)
	if err != nil {
		return err
	}
	// Serialize `TaxableSideType` param:
	err = encoder.Encode(obj.TaxableSideType)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeDistribution` param:
	err = encoder.Encode(obj.CreatorTradingFeeDistribution)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeClaimStatus` param:
	err = encoder.Encode(obj.CreatorTradingFeeClaimStatus)
	if err != nil {
		return err
	}
	// Serialize `FeeConfigurationMode` param:
	err = encoder.Encode(obj.FeeConfigurationMode)
	if err != nil {
		return err
	}
	// Serialize `IsMigrated` param:
	err = encoder.Encode(obj.IsMigrated)
	if err != nil {
		return err
	}
	// Serialize `Pad` param:
	err = encoder.Encode(obj.Pad)
	if err != nil {
		return err
	}
	// Serialize `SlotOffsetBasedFees` param:
	err = encoder.Encode(obj.SlotOffsetBasedFees)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeReceiver` param:
	err = encoder.Encode(obj.CreatorTradingFeeReceiver)
	if err != nil {
		return err
	}
	return nil
}

func (obj *LiquidityPoolStateAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(LiquidityPoolStateAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[190 158 220 130 15 162 132 252]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Info`:
	err = decoder.Decode(&obj.Info)
	if err != nil {
		return err
	}
	// Deserialize `MarketCapBasedFees`:
	err = decoder.Decode(&obj.MarketCapBasedFees)
	if err != nil {
		return err
	}
	// Deserialize `Reserve`:
	err = decoder.Decode(&obj.Reserve)
	if err != nil {
		return err
	}
	// Deserialize `LpToken`:
	err = decoder.Decode(&obj.LpToken)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolTradingFees`:
	err = decoder.Decode(&obj.ProtocolTradingFees)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFees`:
	err = decoder.Decode(&obj.CreatorTradingFees)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeesClaimedByCreator`:
	err = decoder.Decode(&obj.CreatorTradingFeesClaimedByCreator)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeesClaimedByOthers`:
	err = decoder.Decode(&obj.CreatorTradingFeesClaimedByOthers)
	if err != nil {
		return err
	}
	// Deserialize `LiquidityProviderTradingFees`:
	err = decoder.Decode(&obj.LiquidityProviderTradingFees)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeProtocolFees`:
	err = decoder.Decode(&obj.CreatorTradingFeeProtocolFees)
	if err != nil {
		return err
	}
	// Deserialize `ReflectionTradingFees`:
	err = decoder.Decode(&obj.ReflectionTradingFees)
	if err != nil {
		return err
	}
	// Deserialize `CreatedAtSlot`:
	err = decoder.Decode(&obj.CreatedAtSlot)
	if err != nil {
		return err
	}
	// Deserialize `TradingVolumeUsd`:
	err = decoder.Decode(&obj.TradingVolumeUsd)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeTradingVolumeThreshold`:
	err = decoder.Decode(&obj.CreatorTradingFeeTradingVolumeThreshold)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp`:
	err = decoder.Decode(&obj.CreatorTradingFeeTradingVolumeThresholdReachedUnixTimestamp)
	if err != nil {
		return err
	}
	// Deserialize `TokenAVault`:
	err = decoder.Decode(&obj.TokenAVault)
	if err != nil {
		return err
	}
	// Deserialize `TokenBVault`:
	err = decoder.Decode(&obj.TokenBVault)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolConfig`:
	err = decoder.Decode(&obj.ProtocolConfig)
	if err != nil {
		return err
	}
	// Deserialize `Key`:
	err = decoder.Decode(&obj.Key)
	if err != nil {
		return err
	}
	// Deserialize `TokenA`:
	err = decoder.Decode(&obj.TokenA)
	if err != nil {
		return err
	}
	// Deserialize `TokenB`:
	err = decoder.Decode(&obj.TokenB)
	if err != nil {
		return err
	}
	// Deserialize `Allowlist`:
	err = decoder.Decode(&obj.Allowlist)
	if err != nil {
		return err
	}
	// Deserialize `FeatureFlags`:
	err = decoder.Decode(&obj.FeatureFlags)
	if err != nil {
		return err
	}
	// Deserialize `TaxableSide`:
	err = decoder.Decode(&obj.TaxableSide)
	if err != nil {
		return err
	}
	// Deserialize `TaxableSideType`:
	err = decoder.Decode(&obj.TaxableSideType)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeDistribution`:
	err = decoder.Decode(&obj.CreatorTradingFeeDistribution)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeClaimStatus`:
	err = decoder.Decode(&obj.CreatorTradingFeeClaimStatus)
	if err != nil {
		return err
	}
	// Deserialize `FeeConfigurationMode`:
	err = decoder.Decode(&obj.FeeConfigurationMode)
	if err != nil {
		return err
	}
	// Deserialize `IsMigrated`:
	err = decoder.Decode(&obj.IsMigrated)
	if err != nil {
		return err
	}
	// Deserialize `Pad`:
	err = decoder.Decode(&obj.Pad)
	if err != nil {
		return err
	}
	// Deserialize `SlotOffsetBasedFees`:
	err = decoder.Decode(&obj.SlotOffsetBasedFees)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeReceiver`:
	err = decoder.Decode(&obj.CreatorTradingFeeReceiver)
	if err != nil {
		return err
	}
	return nil
}

type MsolTicketSolSpentAccount struct {
	CostBasis    uint64
	MsolUnstaked uint64
}

var MsolTicketSolSpentAccountDiscriminator = [8]byte{66, 196, 62, 134, 124, 149, 250, 66}

func (obj MsolTicketSolSpentAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(MsolTicketSolSpentAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `CostBasis` param:
	err = encoder.Encode(obj.CostBasis)
	if err != nil {
		return err
	}
	// Serialize `MsolUnstaked` param:
	err = encoder.Encode(obj.MsolUnstaked)
	if err != nil {
		return err
	}
	return nil
}

func (obj *MsolTicketSolSpentAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(MsolTicketSolSpentAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[66 196 62 134 124 149 250 66]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `CostBasis`:
	err = decoder.Decode(&obj.CostBasis)
	if err != nil {
		return err
	}
	// Deserialize `MsolUnstaked`:
	err = decoder.Decode(&obj.MsolUnstaked)
	if err != nil {
		return err
	}
	return nil
}

type ProtocolAdminStateAccount struct {
	CurrentProtocolAdmin ag_solanago.PublicKey
}

var ProtocolAdminStateAccountDiscriminator = [8]byte{24, 124, 174, 225, 232, 30, 115, 192}

func (obj ProtocolAdminStateAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ProtocolAdminStateAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `CurrentProtocolAdmin` param:
	err = encoder.Encode(obj.CurrentProtocolAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProtocolAdminStateAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ProtocolAdminStateAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[24 124 174 225 232 30 115 192]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `CurrentProtocolAdmin`:
	err = decoder.Decode(&obj.CurrentProtocolAdmin)
	if err != nil {
		return err
	}
	return nil
}

type ProtocolConfigAccount struct {
	CreatePoolFee                           uint64
	InitialTokenBAmount                     float64
	InitialTokenAAmount                     uint64
	UnstakedWsolReserve                     uint64
	TotalSolSpent                           uint64
	TotalMsolReceived                       uint64
	TotalRealizedProfit                     uint64
	PoolCount                               uint64
	MaxSupplyPerWallet                      uint64
	CreatorTradingFeeTradingVolumeThreshold float64
	MarketCapBasedFees                      LiquidityPoolMarketCapBasedFees
	BufferBps                               uint16
	AutoStakingThresholdBps                 uint16
	Version                                 uint16
	ProtocolConfigStateBump                 uint8
	AllowCreatePool                         uint8
	SupportedPoolType                       uint8
	DefaultLeaderSlotWindow                 uint8
	AutoStakingEnabled                      uint8
	LeaderSlotWindow                        uint8
	SandwichResistenceEnabled               uint8
	TokenADecimals                          uint8
	MigrationMarketCapThreshold             uint16
	Pad                                     [8]uint8
	MaxCreatorTradingFee                    uint32
	SlotOffsetBasedFees                     LiquidityPoolSlotOffsetBasedFees
}

var ProtocolConfigAccountDiscriminator = [8]byte{207, 91, 250, 28, 152, 179, 215, 209}

func (obj ProtocolConfigAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ProtocolConfigAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `CreatePoolFee` param:
	err = encoder.Encode(obj.CreatePoolFee)
	if err != nil {
		return err
	}
	// Serialize `InitialTokenBAmount` param:
	err = encoder.Encode(obj.InitialTokenBAmount)
	if err != nil {
		return err
	}
	// Serialize `InitialTokenAAmount` param:
	err = encoder.Encode(obj.InitialTokenAAmount)
	if err != nil {
		return err
	}
	// Serialize `UnstakedWsolReserve` param:
	err = encoder.Encode(obj.UnstakedWsolReserve)
	if err != nil {
		return err
	}
	// Serialize `TotalSolSpent` param:
	err = encoder.Encode(obj.TotalSolSpent)
	if err != nil {
		return err
	}
	// Serialize `TotalMsolReceived` param:
	err = encoder.Encode(obj.TotalMsolReceived)
	if err != nil {
		return err
	}
	// Serialize `TotalRealizedProfit` param:
	err = encoder.Encode(obj.TotalRealizedProfit)
	if err != nil {
		return err
	}
	// Serialize `PoolCount` param:
	err = encoder.Encode(obj.PoolCount)
	if err != nil {
		return err
	}
	// Serialize `MaxSupplyPerWallet` param:
	err = encoder.Encode(obj.MaxSupplyPerWallet)
	if err != nil {
		return err
	}
	// Serialize `CreatorTradingFeeTradingVolumeThreshold` param:
	err = encoder.Encode(obj.CreatorTradingFeeTradingVolumeThreshold)
	if err != nil {
		return err
	}
	// Serialize `MarketCapBasedFees` param:
	err = encoder.Encode(obj.MarketCapBasedFees)
	if err != nil {
		return err
	}
	// Serialize `BufferBps` param:
	err = encoder.Encode(obj.BufferBps)
	if err != nil {
		return err
	}
	// Serialize `AutoStakingThresholdBps` param:
	err = encoder.Encode(obj.AutoStakingThresholdBps)
	if err != nil {
		return err
	}
	// Serialize `Version` param:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return err
	}
	// Serialize `ProtocolConfigStateBump` param:
	err = encoder.Encode(obj.ProtocolConfigStateBump)
	if err != nil {
		return err
	}
	// Serialize `AllowCreatePool` param:
	err = encoder.Encode(obj.AllowCreatePool)
	if err != nil {
		return err
	}
	// Serialize `SupportedPoolType` param:
	err = encoder.Encode(obj.SupportedPoolType)
	if err != nil {
		return err
	}
	// Serialize `DefaultLeaderSlotWindow` param:
	err = encoder.Encode(obj.DefaultLeaderSlotWindow)
	if err != nil {
		return err
	}
	// Serialize `AutoStakingEnabled` param:
	err = encoder.Encode(obj.AutoStakingEnabled)
	if err != nil {
		return err
	}
	// Serialize `LeaderSlotWindow` param:
	err = encoder.Encode(obj.LeaderSlotWindow)
	if err != nil {
		return err
	}
	// Serialize `SandwichResistenceEnabled` param:
	err = encoder.Encode(obj.SandwichResistenceEnabled)
	if err != nil {
		return err
	}
	// Serialize `TokenADecimals` param:
	err = encoder.Encode(obj.TokenADecimals)
	if err != nil {
		return err
	}
	// Serialize `MigrationMarketCapThreshold` param:
	err = encoder.Encode(obj.MigrationMarketCapThreshold)
	if err != nil {
		return err
	}
	// Serialize `Pad` param:
	err = encoder.Encode(obj.Pad)
	if err != nil {
		return err
	}
	// Serialize `MaxCreatorTradingFee` param:
	err = encoder.Encode(obj.MaxCreatorTradingFee)
	if err != nil {
		return err
	}
	// Serialize `SlotOffsetBasedFees` param:
	err = encoder.Encode(obj.SlotOffsetBasedFees)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProtocolConfigAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ProtocolConfigAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[207 91 250 28 152 179 215 209]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `CreatePoolFee`:
	err = decoder.Decode(&obj.CreatePoolFee)
	if err != nil {
		return err
	}
	// Deserialize `InitialTokenBAmount`:
	err = decoder.Decode(&obj.InitialTokenBAmount)
	if err != nil {
		return err
	}
	// Deserialize `InitialTokenAAmount`:
	err = decoder.Decode(&obj.InitialTokenAAmount)
	if err != nil {
		return err
	}
	// Deserialize `UnstakedWsolReserve`:
	err = decoder.Decode(&obj.UnstakedWsolReserve)
	if err != nil {
		return err
	}
	// Deserialize `TotalSolSpent`:
	err = decoder.Decode(&obj.TotalSolSpent)
	if err != nil {
		return err
	}
	// Deserialize `TotalMsolReceived`:
	err = decoder.Decode(&obj.TotalMsolReceived)
	if err != nil {
		return err
	}
	// Deserialize `TotalRealizedProfit`:
	err = decoder.Decode(&obj.TotalRealizedProfit)
	if err != nil {
		return err
	}
	// Deserialize `PoolCount`:
	err = decoder.Decode(&obj.PoolCount)
	if err != nil {
		return err
	}
	// Deserialize `MaxSupplyPerWallet`:
	err = decoder.Decode(&obj.MaxSupplyPerWallet)
	if err != nil {
		return err
	}
	// Deserialize `CreatorTradingFeeTradingVolumeThreshold`:
	err = decoder.Decode(&obj.CreatorTradingFeeTradingVolumeThreshold)
	if err != nil {
		return err
	}
	// Deserialize `MarketCapBasedFees`:
	err = decoder.Decode(&obj.MarketCapBasedFees)
	if err != nil {
		return err
	}
	// Deserialize `BufferBps`:
	err = decoder.Decode(&obj.BufferBps)
	if err != nil {
		return err
	}
	// Deserialize `AutoStakingThresholdBps`:
	err = decoder.Decode(&obj.AutoStakingThresholdBps)
	if err != nil {
		return err
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return err
	}
	// Deserialize `ProtocolConfigStateBump`:
	err = decoder.Decode(&obj.ProtocolConfigStateBump)
	if err != nil {
		return err
	}
	// Deserialize `AllowCreatePool`:
	err = decoder.Decode(&obj.AllowCreatePool)
	if err != nil {
		return err
	}
	// Deserialize `SupportedPoolType`:
	err = decoder.Decode(&obj.SupportedPoolType)
	if err != nil {
		return err
	}
	// Deserialize `DefaultLeaderSlotWindow`:
	err = decoder.Decode(&obj.DefaultLeaderSlotWindow)
	if err != nil {
		return err
	}
	// Deserialize `AutoStakingEnabled`:
	err = decoder.Decode(&obj.AutoStakingEnabled)
	if err != nil {
		return err
	}
	// Deserialize `LeaderSlotWindow`:
	err = decoder.Decode(&obj.LeaderSlotWindow)
	if err != nil {
		return err
	}
	// Deserialize `SandwichResistenceEnabled`:
	err = decoder.Decode(&obj.SandwichResistenceEnabled)
	if err != nil {
		return err
	}
	// Deserialize `TokenADecimals`:
	err = decoder.Decode(&obj.TokenADecimals)
	if err != nil {
		return err
	}
	// Deserialize `MigrationMarketCapThreshold`:
	err = decoder.Decode(&obj.MigrationMarketCapThreshold)
	if err != nil {
		return err
	}
	// Deserialize `Pad`:
	err = decoder.Decode(&obj.Pad)
	if err != nil {
		return err
	}
	// Deserialize `MaxCreatorTradingFee`:
	err = decoder.Decode(&obj.MaxCreatorTradingFee)
	if err != nil {
		return err
	}
	// Deserialize `SlotOffsetBasedFees`:
	err = decoder.Decode(&obj.SlotOffsetBasedFees)
	if err != nil {
		return err
	}
	return nil
}

type ProtocolOwnerStateAccount struct {
	CurrentProtocolOwner ag_solanago.PublicKey
}

var ProtocolOwnerStateAccountDiscriminator = [8]byte{208, 64, 209, 204, 113, 226, 22, 98}

func (obj ProtocolOwnerStateAccount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ProtocolOwnerStateAccountDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `CurrentProtocolOwner` param:
	err = encoder.Encode(obj.CurrentProtocolOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProtocolOwnerStateAccount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ProtocolOwnerStateAccountDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[208 64 209 204 113 226 22 98]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `CurrentProtocolOwner`:
	err = decoder.Decode(&obj.CurrentProtocolOwner)
	if err != nil {
		return err
	}
	return nil
}
