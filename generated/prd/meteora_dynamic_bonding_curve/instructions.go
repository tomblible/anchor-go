// Code generated by https://github.com/zheng-lan/anchor-go. DO NOT EDIT.

package meteora_dynamic_bonding_curve

import (
	"bytes"
	"fmt"
	ag_spew "github.com/davecgh/go-spew/spew"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_text "github.com/gagliardetto/solana-go/text"
	ag_treeout "github.com/gagliardetto/treeout"
)

const ProgramName = "MeteoraDynamicBondingCurve"

var ProgramID ag_solanago.PublicKey = ag_solanago.MustPublicKeyFromBase58("dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN")

func SetProgramID(PublicKey ag_solanago.PublicKey) {
	ProgramID = PublicKey
	ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
}

func init() {
	if !ProgramID.IsZero() {
		ag_solanago.RegisterInstructionDecoder(ProgramID, registryDecodeInstruction)
	}
}

var (
	AmmProgram = ag_solanago.MustPublicKeyFromBase58("cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG")

	EventAuthorityPDA = ag_solanago.MustPublicKeyFromBase58("8Ks12pbrD6PXxfty1hVQiE9sc289zgU1zHkvXhrSdriF")

	LockerProgram = ag_solanago.MustPublicKeyFromBase58("LocpQgucEQHbqNABEYvBvwoxCPsSbG91A1QaQhQQqjn")

	MeteoraPoolsProgram = ag_solanago.MustPublicKeyFromBase58("Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB")

	PoolAuthority = ag_solanago.MustPublicKeyFromBase58("FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM")

	SystemProgram = ag_solanago.MustPublicKeyFromBase58("11111111111111111111111111111111")

	Token22Program = ag_solanago.MustPublicKeyFromBase58("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb")

	TokenMetadataProgram = ag_solanago.MustPublicKeyFromBase58("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")

	TokenProgram = ag_solanago.MustPublicKeyFromBase58("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
)

var (
	Instruction_ClaimCreatorTradingFee = ag_binary.TypeID([8]byte{82, 220, 250, 189, 3, 85, 107, 45})

	Instruction_ClaimProtocolFee = ag_binary.TypeID([8]byte{165, 228, 133, 48, 99, 249, 255, 33})

	Instruction_ClaimTradingFee = ag_binary.TypeID([8]byte{8, 236, 89, 49, 152, 125, 177, 81})

	Instruction_CloseClaimFeeOperator = ag_binary.TypeID([8]byte{38, 134, 82, 216, 95, 124, 17, 99})

	// ADMIN FUNCTIONS ///
	Instruction_CreateClaimFeeOperator = ag_binary.TypeID([8]byte{169, 62, 207, 107, 58, 187, 162, 109})

	Instruction_CreateConfig = ag_binary.TypeID([8]byte{201, 207, 243, 114, 75, 111, 47, 189})

	// PERMISSIONLESS FUNCTIONS ///
	// create locker
	Instruction_CreateLocker = ag_binary.TypeID([8]byte{167, 90, 137, 154, 75, 47, 17, 84})

	// PARTNER FUNCTIONS ////
	Instruction_CreatePartnerMetadata = ag_binary.TypeID([8]byte{192, 168, 234, 191, 188, 226, 227, 255})

	Instruction_CreateVirtualPoolMetadata = ag_binary.TypeID([8]byte{45, 97, 187, 103, 254, 109, 124, 134})

	Instruction_CreatorWithdrawSurplus = ag_binary.TypeID([8]byte{165, 3, 137, 7, 28, 134, 76, 80})

	// POOL CREATOR FUNCTIONS ////
	Instruction_InitializeVirtualPoolWithSplToken = ag_binary.TypeID([8]byte{140, 85, 215, 176, 102, 54, 104, 79})

	Instruction_InitializeVirtualPoolWithToken2022 = ag_binary.TypeID([8]byte{169, 118, 51, 78, 145, 110, 220, 155})

	Instruction_MigrateMeteoraDamm = ag_binary.TypeID([8]byte{27, 1, 48, 22, 180, 63, 118, 217})

	Instruction_MigrateMeteoraDammClaimLpToken = ag_binary.TypeID([8]byte{139, 133, 2, 30, 91, 145, 127, 154})

	Instruction_MigrateMeteoraDammLockLpToken = ag_binary.TypeID([8]byte{177, 55, 238, 157, 251, 88, 165, 42})

	Instruction_MigrationDammV2 = ag_binary.TypeID([8]byte{156, 169, 230, 103, 53, 228, 80, 64})

	Instruction_MigrationDammV2CreateMetadata = ag_binary.TypeID([8]byte{109, 189, 19, 36, 195, 183, 222, 82})

	// migrate damm v1
	Instruction_MigrationMeteoraDammCreateMetadata = ag_binary.TypeID([8]byte{47, 94, 126, 115, 221, 226, 194, 133})

	Instruction_PartnerWithdrawSurplus = ag_binary.TypeID([8]byte{168, 173, 72, 100, 201, 98, 38, 92})

	Instruction_ProtocolWithdrawSurplus = ag_binary.TypeID([8]byte{54, 136, 225, 138, 172, 182, 214, 167})

	// TRADING BOTS FUNCTIONS ////
	Instruction_Swap = ag_binary.TypeID([8]byte{248, 198, 158, 145, 225, 117, 135, 200})

	Instruction_TransferPoolCreator = ag_binary.TypeID([8]byte{20, 7, 169, 33, 58, 147, 166, 33})

	Instruction_WithdrawLeftover = ag_binary.TypeID([8]byte{20, 198, 202, 237, 235, 243, 183, 66})

	// BOTH partner and creator FUNCTIONS ///
	Instruction_WithdrawMigrationFee = ag_binary.TypeID([8]byte{237, 142, 45, 23, 129, 6, 222, 162})
)

// InstructionIDToName returns the name of the instruction given its ID.
func InstructionIDToName(id ag_binary.TypeID) string {
	switch id {
	case Instruction_ClaimCreatorTradingFee:
		return "ClaimCreatorTradingFee"
	case Instruction_ClaimProtocolFee:
		return "ClaimProtocolFee"
	case Instruction_ClaimTradingFee:
		return "ClaimTradingFee"
	case Instruction_CloseClaimFeeOperator:
		return "CloseClaimFeeOperator"
	case Instruction_CreateClaimFeeOperator:
		return "CreateClaimFeeOperator"
	case Instruction_CreateConfig:
		return "CreateConfig"
	case Instruction_CreateLocker:
		return "CreateLocker"
	case Instruction_CreatePartnerMetadata:
		return "CreatePartnerMetadata"
	case Instruction_CreateVirtualPoolMetadata:
		return "CreateVirtualPoolMetadata"
	case Instruction_CreatorWithdrawSurplus:
		return "CreatorWithdrawSurplus"
	case Instruction_InitializeVirtualPoolWithSplToken:
		return "InitializeVirtualPoolWithSplToken"
	case Instruction_InitializeVirtualPoolWithToken2022:
		return "InitializeVirtualPoolWithToken2022"
	case Instruction_MigrateMeteoraDamm:
		return "MigrateMeteoraDamm"
	case Instruction_MigrateMeteoraDammClaimLpToken:
		return "MigrateMeteoraDammClaimLpToken"
	case Instruction_MigrateMeteoraDammLockLpToken:
		return "MigrateMeteoraDammLockLpToken"
	case Instruction_MigrationDammV2:
		return "MigrationDammV2"
	case Instruction_MigrationDammV2CreateMetadata:
		return "MigrationDammV2CreateMetadata"
	case Instruction_MigrationMeteoraDammCreateMetadata:
		return "MigrationMeteoraDammCreateMetadata"
	case Instruction_PartnerWithdrawSurplus:
		return "PartnerWithdrawSurplus"
	case Instruction_ProtocolWithdrawSurplus:
		return "ProtocolWithdrawSurplus"
	case Instruction_Swap:
		return "Swap"
	case Instruction_TransferPoolCreator:
		return "TransferPoolCreator"
	case Instruction_WithdrawLeftover:
		return "WithdrawLeftover"
	case Instruction_WithdrawMigrationFee:
		return "WithdrawMigrationFee"
	default:
		return ""
	}
}

type Instruction struct {
	ag_binary.BaseVariant
}

func (inst *Instruction) EncodeToTree(parent ag_treeout.Branches) {
	if enToTree, ok := inst.Impl.(ag_text.EncodableToTree); ok {
		enToTree.EncodeToTree(parent)
	} else {
		parent.Child(ag_spew.Sdump(inst))
	}
}

var InstructionImplDef = ag_binary.NewVariantDefinition(
	ag_binary.AnchorTypeIDEncoding,
	[]ag_binary.VariantType{
		{
			Name: "claim_creator_trading_fee", Type: (*ClaimCreatorTradingFee)(nil),
		},
		{
			Name: "claim_protocol_fee", Type: (*ClaimProtocolFee)(nil),
		},
		{
			Name: "claim_trading_fee", Type: (*ClaimTradingFee)(nil),
		},
		{
			Name: "close_claim_fee_operator", Type: (*CloseClaimFeeOperator)(nil),
		},
		{
			Name: "create_claim_fee_operator", Type: (*CreateClaimFeeOperator)(nil),
		},
		{
			Name: "create_config", Type: (*CreateConfig)(nil),
		},
		{
			Name: "create_locker", Type: (*CreateLocker)(nil),
		},
		{
			Name: "create_partner_metadata", Type: (*CreatePartnerMetadata)(nil),
		},
		{
			Name: "create_virtual_pool_metadata", Type: (*CreateVirtualPoolMetadata)(nil),
		},
		{
			Name: "creator_withdraw_surplus", Type: (*CreatorWithdrawSurplus)(nil),
		},
		{
			Name: "initialize_virtual_pool_with_spl_token", Type: (*InitializeVirtualPoolWithSplToken)(nil),
		},
		{
			Name: "initialize_virtual_pool_with_token2022", Type: (*InitializeVirtualPoolWithToken2022)(nil),
		},
		{
			Name: "migrate_meteora_damm", Type: (*MigrateMeteoraDamm)(nil),
		},
		{
			Name: "migrate_meteora_damm_claim_lp_token", Type: (*MigrateMeteoraDammClaimLpToken)(nil),
		},
		{
			Name: "migrate_meteora_damm_lock_lp_token", Type: (*MigrateMeteoraDammLockLpToken)(nil),
		},
		{
			Name: "migration_damm_v2", Type: (*MigrationDammV2)(nil),
		},
		{
			Name: "migration_damm_v2_create_metadata", Type: (*MigrationDammV2CreateMetadata)(nil),
		},
		{
			Name: "migration_meteora_damm_create_metadata", Type: (*MigrationMeteoraDammCreateMetadata)(nil),
		},
		{
			Name: "partner_withdraw_surplus", Type: (*PartnerWithdrawSurplus)(nil),
		},
		{
			Name: "protocol_withdraw_surplus", Type: (*ProtocolWithdrawSurplus)(nil),
		},
		{
			Name: "swap", Type: (*Swap)(nil),
		},
		{
			Name: "transfer_pool_creator", Type: (*TransferPoolCreator)(nil),
		},
		{
			Name: "withdraw_leftover", Type: (*WithdrawLeftover)(nil),
		},
		{
			Name: "withdraw_migration_fee", Type: (*WithdrawMigrationFee)(nil),
		},
	},
)

func (inst *Instruction) ProgramID() ag_solanago.PublicKey {
	return ProgramID
}

func (inst *Instruction) Accounts() (out []*ag_solanago.AccountMeta) {
	return inst.Impl.(ag_solanago.AccountsGettable).GetAccounts()
}

func (inst *Instruction) Data() ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := ag_binary.NewBorshEncoder(buf).Encode(inst); err != nil {
		return nil, fmt.Errorf("unable to encode instruction: %w", err)
	}
	return buf.Bytes(), nil
}

func (inst *Instruction) TextEncode(encoder *ag_text.Encoder, option *ag_text.Option) error {
	return encoder.Encode(inst.Impl, option)
}

func (inst *Instruction) UnmarshalWithDecoder(decoder *ag_binary.Decoder) error {
	return inst.BaseVariant.UnmarshalBinaryVariant(decoder, InstructionImplDef)
}

func (inst *Instruction) MarshalWithEncoder(encoder *ag_binary.Encoder) error {
	err := encoder.WriteBytes(inst.TypeID.Bytes(), false)
	if err != nil {
		return fmt.Errorf("unable to write variant type: %w", err)
	}
	return encoder.Encode(inst.Impl)
}

func registryDecodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (interface{}, error) {
	inst, err := decodeInstruction(accounts, data)
	if err != nil {
		return nil, err
	}
	return inst, nil
}

func decodeInstruction(accounts []*ag_solanago.AccountMeta, data []byte) (*Instruction, error) {
	inst := new(Instruction)
	if err := ag_binary.NewBorshDecoder(data).Decode(inst); err != nil {
		return nil, fmt.Errorf("unable to decode instruction: %w", err)
	}
	if v, ok := inst.Impl.(ag_solanago.AccountsSettable); ok {
		err := v.SetAccounts(accounts)
		if err != nil {
			return nil, fmt.Errorf("unable to set accounts for instruction: %w", err)
		}
	}
	return inst, nil
}
